/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.0
 * source: google/protobuf/descriptor.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace google.protobuf {
    export enum Edition {
        EDITION_UNKNOWN = 0,
        EDITION_LEGACY = 900,
        EDITION_PROTO2 = 998,
        EDITION_PROTO3 = 999,
        EDITION_2023 = 1000,
        EDITION_2024 = 1001,
        EDITION_1_TEST_ONLY = 1,
        EDITION_2_TEST_ONLY = 2,
        EDITION_99997_TEST_ONLY = 99997,
        EDITION_99998_TEST_ONLY = 99998,
        EDITION_99999_TEST_ONLY = 99999,
        EDITION_MAX = 2147483647
    }
    export class FileDescriptorSet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            file: FileDescriptorProto[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.file = data.file;
            }
        }
        get file() {
            return pb_1.Message.getRepeatedWrapperField(this, FileDescriptorProto, 1) as FileDescriptorProto[];
        }
        set file(value: FileDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            file?: ReturnType<typeof FileDescriptorProto.prototype.toObject>[];
        }): FileDescriptorSet {
            const message = new FileDescriptorSet({
                file: data.file.map(item => FileDescriptorProto.fromObject(item))
            });
            return message;
        }
        toObject() {
            const data: {
                file?: ReturnType<typeof FileDescriptorProto.prototype.toObject>[];
            } = {};
            if (this.file != null) {
                data.file = this.file.map((item: FileDescriptorProto) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.file.length)
                writer.writeRepeatedMessage(1, this.file, (item: FileDescriptorProto) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileDescriptorSet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileDescriptorSet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.file, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FileDescriptorProto.deserialize(reader), FileDescriptorProto));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileDescriptorSet {
            return FileDescriptorSet.deserialize(bytes);
        }
    }
    export class FileDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            package?: string;
            dependency: string[];
            publicDependency: number[];
            weakDependency: number[];
            messageType: DescriptorProto[];
            enumType: EnumDescriptorProto[];
            service: ServiceDescriptorProto[];
            extension: FieldDescriptorProto[];
            options?: FileOptions;
            sourceCodeInfo?: SourceCodeInfo;
            syntax?: string;
            edition?: Edition;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 10, 11, 4, 5, 6, 7], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("package" in data && data.package != undefined) {
                    this.package = data.package;
                }
                this.dependency = data.dependency;
                this.publicDependency = data.publicDependency;
                this.weakDependency = data.weakDependency;
                this.messageType = data.messageType;
                this.enumType = data.enumType;
                this.service = data.service;
                this.extension = data.extension;
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                if ("sourceCodeInfo" in data && data.sourceCodeInfo != undefined) {
                    this.sourceCodeInfo = data.sourceCodeInfo;
                }
                if ("syntax" in data && data.syntax != undefined) {
                    this.syntax = data.syntax;
                }
                if ("edition" in data && data.edition != undefined) {
                    this.edition = data.edition;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get package() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set package(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasPackage() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get dependency() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set dependency(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get publicDependency() {
            return pb_1.Message.getFieldWithDefault(this, 10, []) as number[];
        }
        set publicDependency(value: number[]) {
            pb_1.Message.setField(this, 10, value);
        }
        get weakDependency() {
            return pb_1.Message.getFieldWithDefault(this, 11, []) as number[];
        }
        set weakDependency(value: number[]) {
            pb_1.Message.setField(this, 11, value);
        }
        get messageType() {
            return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto, 4) as DescriptorProto[];
        }
        set messageType(value: DescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get enumType() {
            return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProto, 5) as EnumDescriptorProto[];
        }
        set enumType(value: EnumDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get service() {
            return pb_1.Message.getRepeatedWrapperField(this, ServiceDescriptorProto, 6) as ServiceDescriptorProto[];
        }
        set service(value: ServiceDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get extension() {
            return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 7) as FieldDescriptorProto[];
        }
        set extension(value: FieldDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get options() {
            return pb_1.Message.getWrapperField(this, FileOptions, 8) as FileOptions;
        }
        set options(value: FileOptions) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get sourceCodeInfo() {
            return pb_1.Message.getWrapperField(this, SourceCodeInfo, 9) as SourceCodeInfo;
        }
        set sourceCodeInfo(value: SourceCodeInfo) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get hasSourceCodeInfo() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get syntax() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set syntax(value: string) {
            pb_1.Message.setField(this, 12, value);
        }
        get hasSyntax() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get edition() {
            return pb_1.Message.getFieldWithDefault(this, 14, Edition.EDITION_UNKNOWN) as Edition;
        }
        set edition(value: Edition) {
            pb_1.Message.setField(this, 14, value);
        }
        get hasEdition() {
            return pb_1.Message.getField(this, 14) != null;
        }
        static fromObject(data: {
            name?: string;
            package?: string;
            dependency: string[];
            publicDependency: number[];
            weakDependency: number[];
            messageType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
            enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
            service?: ReturnType<typeof ServiceDescriptorProto.prototype.toObject>[];
            extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof FileOptions.prototype.toObject>;
            sourceCodeInfo?: ReturnType<typeof SourceCodeInfo.prototype.toObject>;
            syntax?: string;
            edition?: Edition;
        }): FileDescriptorProto {
            const message = new FileDescriptorProto({
                dependency: data.dependency,
                publicDependency: data.publicDependency,
                weakDependency: data.weakDependency,
                messageType: data.messageType.map(item => DescriptorProto.fromObject(item)),
                enumType: data.enumType.map(item => EnumDescriptorProto.fromObject(item)),
                service: data.service.map(item => ServiceDescriptorProto.fromObject(item)),
                extension: data.extension.map(item => FieldDescriptorProto.fromObject(item))
            });
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.package != null) {
                message.package = data.package;
            }
            if (data.options != null) {
                message.options = FileOptions.fromObject(data.options);
            }
            if (data.sourceCodeInfo != null) {
                message.sourceCodeInfo = SourceCodeInfo.fromObject(data.sourceCodeInfo);
            }
            if (data.syntax != null) {
                message.syntax = data.syntax;
            }
            if (data.edition != null) {
                message.edition = data.edition;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                package?: string;
                dependency: string[];
                publicDependency: number[];
                weakDependency: number[];
                messageType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
                enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
                service?: ReturnType<typeof ServiceDescriptorProto.prototype.toObject>[];
                extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
                options?: ReturnType<typeof FileOptions.prototype.toObject>;
                sourceCodeInfo?: ReturnType<typeof SourceCodeInfo.prototype.toObject>;
                syntax?: string;
                edition?: Edition;
            } = {
                dependency: this.dependency,
                publicDependency: this.publicDependency,
                weakDependency: this.weakDependency
            };
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.package != null) {
                data.package = this.package;
            }
            if (this.messageType != null) {
                data.messageType = this.messageType.map((item: DescriptorProto) => item.toObject());
            }
            if (this.enumType != null) {
                data.enumType = this.enumType.map((item: EnumDescriptorProto) => item.toObject());
            }
            if (this.service != null) {
                data.service = this.service.map((item: ServiceDescriptorProto) => item.toObject());
            }
            if (this.extension != null) {
                data.extension = this.extension.map((item: FieldDescriptorProto) => item.toObject());
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            if (this.sourceCodeInfo != null) {
                data.sourceCodeInfo = this.sourceCodeInfo.toObject();
            }
            if (this.syntax != null) {
                data.syntax = this.syntax;
            }
            if (this.edition != null) {
                data.edition = this.edition;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.hasPackage && this.package.length)
                writer.writeString(2, this.package);
            if (this.dependency.length)
                writer.writeRepeatedString(3, this.dependency);
            if (this.publicDependency.length)
                writer.writeRepeatedInt32(10, this.publicDependency);
            if (this.weakDependency.length)
                writer.writeRepeatedInt32(11, this.weakDependency);
            if (this.messageType.length)
                writer.writeRepeatedMessage(4, this.messageType, (item: DescriptorProto) => item.serialize(writer));
            if (this.enumType.length)
                writer.writeRepeatedMessage(5, this.enumType, (item: EnumDescriptorProto) => item.serialize(writer));
            if (this.service.length)
                writer.writeRepeatedMessage(6, this.service, (item: ServiceDescriptorProto) => item.serialize(writer));
            if (this.extension.length)
                writer.writeRepeatedMessage(7, this.extension, (item: FieldDescriptorProto) => item.serialize(writer));
            if (this.hasOptions)
                writer.writeMessage(8, this.options, () => this.options.serialize(writer));
            if (this.hasSourceCodeInfo)
                writer.writeMessage(9, this.sourceCodeInfo, () => this.sourceCodeInfo.serialize(writer));
            if (this.hasSyntax && this.syntax.length)
                writer.writeString(12, this.syntax);
            if (this.hasEdition)
                writer.writeEnum(14, this.edition);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.package = reader.readString();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 10:
                        pb_1.Message.addToRepeatedField(message, 10, reader.readInt32());
                        break;
                    case 11:
                        pb_1.Message.addToRepeatedField(message, 11, reader.readInt32());
                        break;
                    case 4:
                        reader.readMessage(message.messageType, () => pb_1.Message.addToRepeatedWrapperField(message, 4, DescriptorProto.deserialize(reader), DescriptorProto));
                        break;
                    case 5:
                        reader.readMessage(message.enumType, () => pb_1.Message.addToRepeatedWrapperField(message, 5, EnumDescriptorProto.deserialize(reader), EnumDescriptorProto));
                        break;
                    case 6:
                        reader.readMessage(message.service, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ServiceDescriptorProto.deserialize(reader), ServiceDescriptorProto));
                        break;
                    case 7:
                        reader.readMessage(message.extension, () => pb_1.Message.addToRepeatedWrapperField(message, 7, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                        break;
                    case 8:
                        reader.readMessage(message.options, () => message.options = FileOptions.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.sourceCodeInfo, () => message.sourceCodeInfo = SourceCodeInfo.deserialize(reader));
                        break;
                    case 12:
                        message.syntax = reader.readString();
                        break;
                    case 14:
                        message.edition = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileDescriptorProto {
            return FileDescriptorProto.deserialize(bytes);
        }
    }
    export class DescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            field: FieldDescriptorProto[];
            extension: FieldDescriptorProto[];
            nestedType: DescriptorProto[];
            enumType: EnumDescriptorProto[];
            extensionRange: DescriptorProto.ExtensionRange[];
            oneofDecl: OneofDescriptorProto[];
            options?: MessageOptions;
            reservedRange: DescriptorProto.ReservedRange[];
            reservedName: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 6, 3, 4, 5, 8, 9, 10], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                this.field = data.field;
                this.extension = data.extension;
                this.nestedType = data.nestedType;
                this.enumType = data.enumType;
                this.extensionRange = data.extensionRange;
                this.oneofDecl = data.oneofDecl;
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                this.reservedRange = data.reservedRange;
                this.reservedName = data.reservedName;
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get field() {
            return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 2) as FieldDescriptorProto[];
        }
        set field(value: FieldDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get extension() {
            return pb_1.Message.getRepeatedWrapperField(this, FieldDescriptorProto, 6) as FieldDescriptorProto[];
        }
        set extension(value: FieldDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get nestedType() {
            return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto, 3) as DescriptorProto[];
        }
        set nestedType(value: DescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get enumType() {
            return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProto, 4) as EnumDescriptorProto[];
        }
        set enumType(value: EnumDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get extensionRange() {
            return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto.ExtensionRange, 5) as DescriptorProto.ExtensionRange[];
        }
        set extensionRange(value: DescriptorProto.ExtensionRange[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get oneofDecl() {
            return pb_1.Message.getRepeatedWrapperField(this, OneofDescriptorProto, 8) as OneofDescriptorProto[];
        }
        set oneofDecl(value: OneofDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get options() {
            return pb_1.Message.getWrapperField(this, MessageOptions, 7) as MessageOptions;
        }
        set options(value: MessageOptions) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get reservedRange() {
            return pb_1.Message.getRepeatedWrapperField(this, DescriptorProto.ReservedRange, 9) as DescriptorProto.ReservedRange[];
        }
        set reservedRange(value: DescriptorProto.ReservedRange[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        get reservedName() {
            return pb_1.Message.getFieldWithDefault(this, 10, []) as string[];
        }
        set reservedName(value: string[]) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            name?: string;
            field?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
            nestedType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
            enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
            extensionRange?: ReturnType<typeof DescriptorProto.ExtensionRange.prototype.toObject>[];
            oneofDecl?: ReturnType<typeof OneofDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof MessageOptions.prototype.toObject>;
            reservedRange?: ReturnType<typeof DescriptorProto.ReservedRange.prototype.toObject>[];
            reservedName: string[];
        }): DescriptorProto {
            const message = new DescriptorProto({
                field: data.field.map(item => FieldDescriptorProto.fromObject(item)),
                extension: data.extension.map(item => FieldDescriptorProto.fromObject(item)),
                nestedType: data.nestedType.map(item => DescriptorProto.fromObject(item)),
                enumType: data.enumType.map(item => EnumDescriptorProto.fromObject(item)),
                extensionRange: data.extensionRange.map(item => DescriptorProto.ExtensionRange.fromObject(item)),
                oneofDecl: data.oneofDecl.map(item => OneofDescriptorProto.fromObject(item)),
                reservedRange: data.reservedRange.map(item => DescriptorProto.ReservedRange.fromObject(item)),
                reservedName: data.reservedName
            });
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.options != null) {
                message.options = MessageOptions.fromObject(data.options);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                field?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
                extension?: ReturnType<typeof FieldDescriptorProto.prototype.toObject>[];
                nestedType?: ReturnType<typeof DescriptorProto.prototype.toObject>[];
                enumType?: ReturnType<typeof EnumDescriptorProto.prototype.toObject>[];
                extensionRange?: ReturnType<typeof DescriptorProto.ExtensionRange.prototype.toObject>[];
                oneofDecl?: ReturnType<typeof OneofDescriptorProto.prototype.toObject>[];
                options?: ReturnType<typeof MessageOptions.prototype.toObject>;
                reservedRange?: ReturnType<typeof DescriptorProto.ReservedRange.prototype.toObject>[];
                reservedName: string[];
            } = {
                reservedName: this.reservedName
            };
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.field != null) {
                data.field = this.field.map((item: FieldDescriptorProto) => item.toObject());
            }
            if (this.extension != null) {
                data.extension = this.extension.map((item: FieldDescriptorProto) => item.toObject());
            }
            if (this.nestedType != null) {
                data.nestedType = this.nestedType.map((item: DescriptorProto) => item.toObject());
            }
            if (this.enumType != null) {
                data.enumType = this.enumType.map((item: EnumDescriptorProto) => item.toObject());
            }
            if (this.extensionRange != null) {
                data.extensionRange = this.extensionRange.map((item: DescriptorProto.ExtensionRange) => item.toObject());
            }
            if (this.oneofDecl != null) {
                data.oneofDecl = this.oneofDecl.map((item: OneofDescriptorProto) => item.toObject());
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            if (this.reservedRange != null) {
                data.reservedRange = this.reservedRange.map((item: DescriptorProto.ReservedRange) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.field.length)
                writer.writeRepeatedMessage(2, this.field, (item: FieldDescriptorProto) => item.serialize(writer));
            if (this.extension.length)
                writer.writeRepeatedMessage(6, this.extension, (item: FieldDescriptorProto) => item.serialize(writer));
            if (this.nestedType.length)
                writer.writeRepeatedMessage(3, this.nestedType, (item: DescriptorProto) => item.serialize(writer));
            if (this.enumType.length)
                writer.writeRepeatedMessage(4, this.enumType, (item: EnumDescriptorProto) => item.serialize(writer));
            if (this.extensionRange.length)
                writer.writeRepeatedMessage(5, this.extensionRange, (item: DescriptorProto.ExtensionRange) => item.serialize(writer));
            if (this.oneofDecl.length)
                writer.writeRepeatedMessage(8, this.oneofDecl, (item: OneofDescriptorProto) => item.serialize(writer));
            if (this.hasOptions)
                writer.writeMessage(7, this.options, () => this.options.serialize(writer));
            if (this.reservedRange.length)
                writer.writeRepeatedMessage(9, this.reservedRange, (item: DescriptorProto.ReservedRange) => item.serialize(writer));
            if (this.reservedName.length)
                writer.writeRepeatedString(10, this.reservedName);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.field, () => pb_1.Message.addToRepeatedWrapperField(message, 2, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                        break;
                    case 6:
                        reader.readMessage(message.extension, () => pb_1.Message.addToRepeatedWrapperField(message, 6, FieldDescriptorProto.deserialize(reader), FieldDescriptorProto));
                        break;
                    case 3:
                        reader.readMessage(message.nestedType, () => pb_1.Message.addToRepeatedWrapperField(message, 3, DescriptorProto.deserialize(reader), DescriptorProto));
                        break;
                    case 4:
                        reader.readMessage(message.enumType, () => pb_1.Message.addToRepeatedWrapperField(message, 4, EnumDescriptorProto.deserialize(reader), EnumDescriptorProto));
                        break;
                    case 5:
                        reader.readMessage(message.extensionRange, () => pb_1.Message.addToRepeatedWrapperField(message, 5, DescriptorProto.ExtensionRange.deserialize(reader), DescriptorProto.ExtensionRange));
                        break;
                    case 8:
                        reader.readMessage(message.oneofDecl, () => pb_1.Message.addToRepeatedWrapperField(message, 8, OneofDescriptorProto.deserialize(reader), OneofDescriptorProto));
                        break;
                    case 7:
                        reader.readMessage(message.options, () => message.options = MessageOptions.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.reservedRange, () => pb_1.Message.addToRepeatedWrapperField(message, 9, DescriptorProto.ReservedRange.deserialize(reader), DescriptorProto.ReservedRange));
                        break;
                    case 10:
                        pb_1.Message.addToRepeatedField(message, 10, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DescriptorProto {
            return DescriptorProto.deserialize(bytes);
        }
    }
    export namespace DescriptorProto {
        export class ExtensionRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                start?: number;
                end?: number;
                options?: ExtensionRangeOptions;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("start" in data && data.start != undefined) {
                        this.start = data.start;
                    }
                    if ("end" in data && data.end != undefined) {
                        this.end = data.end;
                    }
                    if ("options" in data && data.options != undefined) {
                        this.options = data.options;
                    }
                }
            }
            get start() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set start(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasStart() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get end() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set end(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasEnd() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get options() {
                return pb_1.Message.getWrapperField(this, ExtensionRangeOptions, 3) as ExtensionRangeOptions;
            }
            set options(value: ExtensionRangeOptions) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get hasOptions() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                start?: number;
                end?: number;
                options?: ReturnType<typeof ExtensionRangeOptions.prototype.toObject>;
            }): ExtensionRange {
                const message = new ExtensionRange({});
                if (data.start != null) {
                    message.start = data.start;
                }
                if (data.end != null) {
                    message.end = data.end;
                }
                if (data.options != null) {
                    message.options = ExtensionRangeOptions.fromObject(data.options);
                }
                return message;
            }
            toObject() {
                const data: {
                    start?: number;
                    end?: number;
                    options?: ReturnType<typeof ExtensionRangeOptions.prototype.toObject>;
                } = {};
                if (this.start != null) {
                    data.start = this.start;
                }
                if (this.end != null) {
                    data.end = this.end;
                }
                if (this.options != null) {
                    data.options = this.options.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasStart)
                    writer.writeInt32(1, this.start);
                if (this.hasEnd)
                    writer.writeInt32(2, this.end);
                if (this.hasOptions)
                    writer.writeMessage(3, this.options, () => this.options.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExtensionRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExtensionRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.start = reader.readInt32();
                            break;
                        case 2:
                            message.end = reader.readInt32();
                            break;
                        case 3:
                            reader.readMessage(message.options, () => message.options = ExtensionRangeOptions.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ExtensionRange {
                return ExtensionRange.deserialize(bytes);
            }
        }
        export class ReservedRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                start?: number;
                end?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("start" in data && data.start != undefined) {
                        this.start = data.start;
                    }
                    if ("end" in data && data.end != undefined) {
                        this.end = data.end;
                    }
                }
            }
            get start() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set start(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasStart() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get end() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set end(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasEnd() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                start?: number;
                end?: number;
            }): ReservedRange {
                const message = new ReservedRange({});
                if (data.start != null) {
                    message.start = data.start;
                }
                if (data.end != null) {
                    message.end = data.end;
                }
                return message;
            }
            toObject() {
                const data: {
                    start?: number;
                    end?: number;
                } = {};
                if (this.start != null) {
                    data.start = this.start;
                }
                if (this.end != null) {
                    data.end = this.end;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasStart)
                    writer.writeInt32(1, this.start);
                if (this.hasEnd)
                    writer.writeInt32(2, this.end);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReservedRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReservedRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.start = reader.readInt32();
                            break;
                        case 2:
                            message.end = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ReservedRange {
                return ReservedRange.deserialize(bytes);
            }
        }
    }
    export class ExtensionRangeOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            uninterpretedOption: UninterpretedOption[];
            declaration: ExtensionRangeOptions.Declaration[];
            features?: FeatureSet;
            verification?: ExtensionRangeOptions.VerificationState;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.uninterpretedOption = data.uninterpretedOption;
                this.declaration = data.declaration;
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("verification" in data && data.verification != undefined) {
                    this.verification = data.verification;
                }
            }
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        get declaration() {
            return pb_1.Message.getRepeatedWrapperField(this, ExtensionRangeOptions.Declaration, 2) as ExtensionRangeOptions.Declaration[];
        }
        set declaration(value: ExtensionRangeOptions.Declaration[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 50) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 50, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 50) != null;
        }
        get verification() {
            return pb_1.Message.getFieldWithDefault(this, 3, ExtensionRangeOptions.VerificationState.UNVERIFIED) as ExtensionRangeOptions.VerificationState;
        }
        set verification(value: ExtensionRangeOptions.VerificationState) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasVerification() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            declaration?: ReturnType<typeof ExtensionRangeOptions.Declaration.prototype.toObject>[];
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            verification?: ExtensionRangeOptions.VerificationState;
        }): ExtensionRangeOptions {
            const message = new ExtensionRangeOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item)),
                declaration: data.declaration.map(item => ExtensionRangeOptions.Declaration.fromObject(item))
            });
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            if (data.verification != null) {
                message.verification = data.verification;
            }
            return message;
        }
        toObject() {
            const data: {
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
                declaration?: ReturnType<typeof ExtensionRangeOptions.Declaration.prototype.toObject>[];
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                verification?: ExtensionRangeOptions.VerificationState;
            } = {};
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            if (this.declaration != null) {
                data.declaration = this.declaration.map((item: ExtensionRangeOptions.Declaration) => item.toObject());
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.verification != null) {
                data.verification = this.verification;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (this.declaration.length)
                writer.writeRepeatedMessage(2, this.declaration, (item: ExtensionRangeOptions.Declaration) => item.serialize(writer));
            if (this.hasFeatures)
                writer.writeMessage(50, this.features, () => this.features.serialize(writer));
            if (this.hasVerification)
                writer.writeEnum(3, this.verification);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExtensionRangeOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExtensionRangeOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    case 2:
                        reader.readMessage(message.declaration, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ExtensionRangeOptions.Declaration.deserialize(reader), ExtensionRangeOptions.Declaration));
                        break;
                    case 50:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 3:
                        message.verification = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExtensionRangeOptions {
            return ExtensionRangeOptions.deserialize(bytes);
        }
    }
    export namespace ExtensionRangeOptions {
        export enum VerificationState {
            DECLARATION = 0,
            UNVERIFIED = 1
        }
        export class Declaration extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                number?: number;
                fullName?: string;
                type?: string;
                reserved?: boolean;
                repeated?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("number" in data && data.number != undefined) {
                        this.number = data.number;
                    }
                    if ("fullName" in data && data.fullName != undefined) {
                        this.fullName = data.fullName;
                    }
                    if ("type" in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ("reserved" in data && data.reserved != undefined) {
                        this.reserved = data.reserved;
                    }
                    if ("repeated" in data && data.repeated != undefined) {
                        this.repeated = data.repeated;
                    }
                }
            }
            get number() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set number(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasNumber() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get fullName() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set fullName(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasFullName() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get type() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set type(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasType() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get reserved() {
                return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
            }
            set reserved(value: boolean) {
                pb_1.Message.setField(this, 5, value);
            }
            get hasReserved() {
                return pb_1.Message.getField(this, 5) != null;
            }
            get repeated() {
                return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
            }
            set repeated(value: boolean) {
                pb_1.Message.setField(this, 6, value);
            }
            get hasRepeated() {
                return pb_1.Message.getField(this, 6) != null;
            }
            static fromObject(data: {
                number?: number;
                fullName?: string;
                type?: string;
                reserved?: boolean;
                repeated?: boolean;
            }): Declaration {
                const message = new Declaration({});
                if (data.number != null) {
                    message.number = data.number;
                }
                if (data.fullName != null) {
                    message.fullName = data.fullName;
                }
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.reserved != null) {
                    message.reserved = data.reserved;
                }
                if (data.repeated != null) {
                    message.repeated = data.repeated;
                }
                return message;
            }
            toObject() {
                const data: {
                    number?: number;
                    fullName?: string;
                    type?: string;
                    reserved?: boolean;
                    repeated?: boolean;
                } = {};
                if (this.number != null) {
                    data.number = this.number;
                }
                if (this.fullName != null) {
                    data.fullName = this.fullName;
                }
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.reserved != null) {
                    data.reserved = this.reserved;
                }
                if (this.repeated != null) {
                    data.repeated = this.repeated;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasNumber)
                    writer.writeInt32(1, this.number);
                if (this.hasFullName && this.fullName.length)
                    writer.writeString(2, this.fullName);
                if (this.hasType && this.type.length)
                    writer.writeString(3, this.type);
                if (this.hasReserved)
                    writer.writeBool(5, this.reserved);
                if (this.hasRepeated)
                    writer.writeBool(6, this.repeated);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Declaration {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Declaration();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.number = reader.readInt32();
                            break;
                        case 2:
                            message.fullName = reader.readString();
                            break;
                        case 3:
                            message.type = reader.readString();
                            break;
                        case 5:
                            message.reserved = reader.readBool();
                            break;
                        case 6:
                            message.repeated = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Declaration {
                return Declaration.deserialize(bytes);
            }
        }
    }
    export class FieldDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            number?: number;
            label?: FieldDescriptorProto.Label;
            type?: FieldDescriptorProto.Type;
            typeName?: string;
            extendee?: string;
            defaultValue?: string;
            oneofIndex?: number;
            jsonName?: string;
            options?: FieldOptions;
            proto3Optional?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("number" in data && data.number != undefined) {
                    this.number = data.number;
                }
                if ("label" in data && data.label != undefined) {
                    this.label = data.label;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("typeName" in data && data.typeName != undefined) {
                    this.typeName = data.typeName;
                }
                if ("extendee" in data && data.extendee != undefined) {
                    this.extendee = data.extendee;
                }
                if ("defaultValue" in data && data.defaultValue != undefined) {
                    this.defaultValue = data.defaultValue;
                }
                if ("oneofIndex" in data && data.oneofIndex != undefined) {
                    this.oneofIndex = data.oneofIndex;
                }
                if ("jsonName" in data && data.jsonName != undefined) {
                    this.jsonName = data.jsonName;
                }
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                if ("proto3Optional" in data && data.proto3Optional != undefined) {
                    this.proto3Optional = data.proto3Optional;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get number() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set number(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasNumber() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get label() {
            return pb_1.Message.getFieldWithDefault(this, 4, FieldDescriptorProto.Label.LABEL_OPTIONAL) as FieldDescriptorProto.Label;
        }
        set label(value: FieldDescriptorProto.Label) {
            pb_1.Message.setField(this, 4, value);
        }
        get hasLabel() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 5, FieldDescriptorProto.Type.TYPE_DOUBLE) as FieldDescriptorProto.Type;
        }
        set type(value: FieldDescriptorProto.Type) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasType() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get typeName() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set typeName(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get hasTypeName() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get extendee() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set extendee(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasExtendee() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get defaultValue() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set defaultValue(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get hasDefaultValue() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get oneofIndex() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set oneofIndex(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get hasOneofIndex() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get jsonName() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set jsonName(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get hasJsonName() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get options() {
            return pb_1.Message.getWrapperField(this, FieldOptions, 8) as FieldOptions;
        }
        set options(value: FieldOptions) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get proto3Optional() {
            return pb_1.Message.getFieldWithDefault(this, 17, false) as boolean;
        }
        set proto3Optional(value: boolean) {
            pb_1.Message.setField(this, 17, value);
        }
        get hasProto3Optional() {
            return pb_1.Message.getField(this, 17) != null;
        }
        static fromObject(data: {
            name?: string;
            number?: number;
            label?: FieldDescriptorProto.Label;
            type?: FieldDescriptorProto.Type;
            typeName?: string;
            extendee?: string;
            defaultValue?: string;
            oneofIndex?: number;
            jsonName?: string;
            options?: ReturnType<typeof FieldOptions.prototype.toObject>;
            proto3Optional?: boolean;
        }): FieldDescriptorProto {
            const message = new FieldDescriptorProto({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.number != null) {
                message.number = data.number;
            }
            if (data.label != null) {
                message.label = data.label;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.typeName != null) {
                message.typeName = data.typeName;
            }
            if (data.extendee != null) {
                message.extendee = data.extendee;
            }
            if (data.defaultValue != null) {
                message.defaultValue = data.defaultValue;
            }
            if (data.oneofIndex != null) {
                message.oneofIndex = data.oneofIndex;
            }
            if (data.jsonName != null) {
                message.jsonName = data.jsonName;
            }
            if (data.options != null) {
                message.options = FieldOptions.fromObject(data.options);
            }
            if (data.proto3Optional != null) {
                message.proto3Optional = data.proto3Optional;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                number?: number;
                label?: FieldDescriptorProto.Label;
                type?: FieldDescriptorProto.Type;
                typeName?: string;
                extendee?: string;
                defaultValue?: string;
                oneofIndex?: number;
                jsonName?: string;
                options?: ReturnType<typeof FieldOptions.prototype.toObject>;
                proto3Optional?: boolean;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.number != null) {
                data.number = this.number;
            }
            if (this.label != null) {
                data.label = this.label;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.typeName != null) {
                data.typeName = this.typeName;
            }
            if (this.extendee != null) {
                data.extendee = this.extendee;
            }
            if (this.defaultValue != null) {
                data.defaultValue = this.defaultValue;
            }
            if (this.oneofIndex != null) {
                data.oneofIndex = this.oneofIndex;
            }
            if (this.jsonName != null) {
                data.jsonName = this.jsonName;
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            if (this.proto3Optional != null) {
                data.proto3Optional = this.proto3Optional;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.hasNumber)
                writer.writeInt32(3, this.number);
            if (this.hasLabel)
                writer.writeEnum(4, this.label);
            if (this.hasType)
                writer.writeEnum(5, this.type);
            if (this.hasTypeName && this.typeName.length)
                writer.writeString(6, this.typeName);
            if (this.hasExtendee && this.extendee.length)
                writer.writeString(2, this.extendee);
            if (this.hasDefaultValue && this.defaultValue.length)
                writer.writeString(7, this.defaultValue);
            if (this.hasOneofIndex)
                writer.writeInt32(9, this.oneofIndex);
            if (this.hasJsonName && this.jsonName.length)
                writer.writeString(10, this.jsonName);
            if (this.hasOptions)
                writer.writeMessage(8, this.options, () => this.options.serialize(writer));
            if (this.hasProto3Optional)
                writer.writeBool(17, this.proto3Optional);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FieldDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FieldDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.number = reader.readInt32();
                        break;
                    case 4:
                        message.label = reader.readEnum();
                        break;
                    case 5:
                        message.type = reader.readEnum();
                        break;
                    case 6:
                        message.typeName = reader.readString();
                        break;
                    case 2:
                        message.extendee = reader.readString();
                        break;
                    case 7:
                        message.defaultValue = reader.readString();
                        break;
                    case 9:
                        message.oneofIndex = reader.readInt32();
                        break;
                    case 10:
                        message.jsonName = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message.options, () => message.options = FieldOptions.deserialize(reader));
                        break;
                    case 17:
                        message.proto3Optional = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FieldDescriptorProto {
            return FieldDescriptorProto.deserialize(bytes);
        }
    }
    export namespace FieldDescriptorProto {
        export enum Type {
            TYPE_DOUBLE = 1,
            TYPE_FLOAT = 2,
            TYPE_INT64 = 3,
            TYPE_UINT64 = 4,
            TYPE_INT32 = 5,
            TYPE_FIXED64 = 6,
            TYPE_FIXED32 = 7,
            TYPE_BOOL = 8,
            TYPE_STRING = 9,
            TYPE_GROUP = 10,
            TYPE_MESSAGE = 11,
            TYPE_BYTES = 12,
            TYPE_UINT32 = 13,
            TYPE_ENUM = 14,
            TYPE_SFIXED32 = 15,
            TYPE_SFIXED64 = 16,
            TYPE_SINT32 = 17,
            TYPE_SINT64 = 18
        }
        export enum Label {
            LABEL_OPTIONAL = 1,
            LABEL_REPEATED = 3,
            LABEL_REQUIRED = 2
        }
    }
    export class OneofDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            options?: OneofOptions;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get options() {
            return pb_1.Message.getWrapperField(this, OneofOptions, 2) as OneofOptions;
        }
        set options(value: OneofOptions) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            name?: string;
            options?: ReturnType<typeof OneofOptions.prototype.toObject>;
        }): OneofDescriptorProto {
            const message = new OneofDescriptorProto({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.options != null) {
                message.options = OneofOptions.fromObject(data.options);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                options?: ReturnType<typeof OneofOptions.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.hasOptions)
                writer.writeMessage(2, this.options, () => this.options.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneofDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneofDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.options, () => message.options = OneofOptions.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OneofDescriptorProto {
            return OneofDescriptorProto.deserialize(bytes);
        }
    }
    export class EnumDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            value: EnumValueDescriptorProto[];
            options?: EnumOptions;
            reservedRange: EnumDescriptorProto.EnumReservedRange[];
            reservedName: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                this.value = data.value;
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                this.reservedRange = data.reservedRange;
                this.reservedName = data.reservedName;
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get value() {
            return pb_1.Message.getRepeatedWrapperField(this, EnumValueDescriptorProto, 2) as EnumValueDescriptorProto[];
        }
        set value(value: EnumValueDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get options() {
            return pb_1.Message.getWrapperField(this, EnumOptions, 3) as EnumOptions;
        }
        set options(value: EnumOptions) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get reservedRange() {
            return pb_1.Message.getRepeatedWrapperField(this, EnumDescriptorProto.EnumReservedRange, 4) as EnumDescriptorProto.EnumReservedRange[];
        }
        set reservedRange(value: EnumDescriptorProto.EnumReservedRange[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get reservedName() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set reservedName(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            name?: string;
            value?: ReturnType<typeof EnumValueDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof EnumOptions.prototype.toObject>;
            reservedRange?: ReturnType<typeof EnumDescriptorProto.EnumReservedRange.prototype.toObject>[];
            reservedName: string[];
        }): EnumDescriptorProto {
            const message = new EnumDescriptorProto({
                value: data.value.map(item => EnumValueDescriptorProto.fromObject(item)),
                reservedRange: data.reservedRange.map(item => EnumDescriptorProto.EnumReservedRange.fromObject(item)),
                reservedName: data.reservedName
            });
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.options != null) {
                message.options = EnumOptions.fromObject(data.options);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                value?: ReturnType<typeof EnumValueDescriptorProto.prototype.toObject>[];
                options?: ReturnType<typeof EnumOptions.prototype.toObject>;
                reservedRange?: ReturnType<typeof EnumDescriptorProto.EnumReservedRange.prototype.toObject>[];
                reservedName: string[];
            } = {
                reservedName: this.reservedName
            };
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.value != null) {
                data.value = this.value.map((item: EnumValueDescriptorProto) => item.toObject());
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            if (this.reservedRange != null) {
                data.reservedRange = this.reservedRange.map((item: EnumDescriptorProto.EnumReservedRange) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.value.length)
                writer.writeRepeatedMessage(2, this.value, (item: EnumValueDescriptorProto) => item.serialize(writer));
            if (this.hasOptions)
                writer.writeMessage(3, this.options, () => this.options.serialize(writer));
            if (this.reservedRange.length)
                writer.writeRepeatedMessage(4, this.reservedRange, (item: EnumDescriptorProto.EnumReservedRange) => item.serialize(writer));
            if (this.reservedName.length)
                writer.writeRepeatedString(5, this.reservedName);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.value, () => pb_1.Message.addToRepeatedWrapperField(message, 2, EnumValueDescriptorProto.deserialize(reader), EnumValueDescriptorProto));
                        break;
                    case 3:
                        reader.readMessage(message.options, () => message.options = EnumOptions.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.reservedRange, () => pb_1.Message.addToRepeatedWrapperField(message, 4, EnumDescriptorProto.EnumReservedRange.deserialize(reader), EnumDescriptorProto.EnumReservedRange));
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EnumDescriptorProto {
            return EnumDescriptorProto.deserialize(bytes);
        }
    }
    export namespace EnumDescriptorProto {
        export class EnumReservedRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                start?: number;
                end?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("start" in data && data.start != undefined) {
                        this.start = data.start;
                    }
                    if ("end" in data && data.end != undefined) {
                        this.end = data.end;
                    }
                }
            }
            get start() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set start(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasStart() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get end() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set end(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasEnd() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                start?: number;
                end?: number;
            }): EnumReservedRange {
                const message = new EnumReservedRange({});
                if (data.start != null) {
                    message.start = data.start;
                }
                if (data.end != null) {
                    message.end = data.end;
                }
                return message;
            }
            toObject() {
                const data: {
                    start?: number;
                    end?: number;
                } = {};
                if (this.start != null) {
                    data.start = this.start;
                }
                if (this.end != null) {
                    data.end = this.end;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasStart)
                    writer.writeInt32(1, this.start);
                if (this.hasEnd)
                    writer.writeInt32(2, this.end);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumReservedRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumReservedRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.start = reader.readInt32();
                            break;
                        case 2:
                            message.end = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EnumReservedRange {
                return EnumReservedRange.deserialize(bytes);
            }
        }
    }
    export class EnumValueDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            number?: number;
            options?: EnumValueOptions;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("number" in data && data.number != undefined) {
                    this.number = data.number;
                }
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get number() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set number(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasNumber() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get options() {
            return pb_1.Message.getWrapperField(this, EnumValueOptions, 3) as EnumValueOptions;
        }
        set options(value: EnumValueOptions) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            name?: string;
            number?: number;
            options?: ReturnType<typeof EnumValueOptions.prototype.toObject>;
        }): EnumValueDescriptorProto {
            const message = new EnumValueDescriptorProto({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.number != null) {
                message.number = data.number;
            }
            if (data.options != null) {
                message.options = EnumValueOptions.fromObject(data.options);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                number?: number;
                options?: ReturnType<typeof EnumValueOptions.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.number != null) {
                data.number = this.number;
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.hasNumber)
                writer.writeInt32(2, this.number);
            if (this.hasOptions)
                writer.writeMessage(3, this.options, () => this.options.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumValueDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumValueDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.number = reader.readInt32();
                        break;
                    case 3:
                        reader.readMessage(message.options, () => message.options = EnumValueOptions.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EnumValueDescriptorProto {
            return EnumValueDescriptorProto.deserialize(bytes);
        }
    }
    export class ServiceDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            method: MethodDescriptorProto[];
            options?: ServiceOptions;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                this.method = data.method;
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get method() {
            return pb_1.Message.getRepeatedWrapperField(this, MethodDescriptorProto, 2) as MethodDescriptorProto[];
        }
        set method(value: MethodDescriptorProto[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get options() {
            return pb_1.Message.getWrapperField(this, ServiceOptions, 3) as ServiceOptions;
        }
        set options(value: ServiceOptions) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            name?: string;
            method?: ReturnType<typeof MethodDescriptorProto.prototype.toObject>[];
            options?: ReturnType<typeof ServiceOptions.prototype.toObject>;
        }): ServiceDescriptorProto {
            const message = new ServiceDescriptorProto({
                method: data.method.map(item => MethodDescriptorProto.fromObject(item))
            });
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.options != null) {
                message.options = ServiceOptions.fromObject(data.options);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                method?: ReturnType<typeof MethodDescriptorProto.prototype.toObject>[];
                options?: ReturnType<typeof ServiceOptions.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.method != null) {
                data.method = this.method.map((item: MethodDescriptorProto) => item.toObject());
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.method.length)
                writer.writeRepeatedMessage(2, this.method, (item: MethodDescriptorProto) => item.serialize(writer));
            if (this.hasOptions)
                writer.writeMessage(3, this.options, () => this.options.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServiceDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServiceDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.method, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MethodDescriptorProto.deserialize(reader), MethodDescriptorProto));
                        break;
                    case 3:
                        reader.readMessage(message.options, () => message.options = ServiceOptions.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ServiceDescriptorProto {
            return ServiceDescriptorProto.deserialize(bytes);
        }
    }
    export class MethodDescriptorProto extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            inputType?: string;
            outputType?: string;
            options?: MethodOptions;
            clientStreaming?: boolean;
            serverStreaming?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("inputType" in data && data.inputType != undefined) {
                    this.inputType = data.inputType;
                }
                if ("outputType" in data && data.outputType != undefined) {
                    this.outputType = data.outputType;
                }
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                if ("clientStreaming" in data && data.clientStreaming != undefined) {
                    this.clientStreaming = data.clientStreaming;
                }
                if ("serverStreaming" in data && data.serverStreaming != undefined) {
                    this.serverStreaming = data.serverStreaming;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasName() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get inputType() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set inputType(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasInputType() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get outputType() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set outputType(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasOutputType() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get options() {
            return pb_1.Message.getWrapperField(this, MethodOptions, 4) as MethodOptions;
        }
        set options(value: MethodOptions) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get hasOptions() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get clientStreaming() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set clientStreaming(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasClientStreaming() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get serverStreaming() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set serverStreaming(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get hasServerStreaming() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            name?: string;
            inputType?: string;
            outputType?: string;
            options?: ReturnType<typeof MethodOptions.prototype.toObject>;
            clientStreaming?: boolean;
            serverStreaming?: boolean;
        }): MethodDescriptorProto {
            const message = new MethodDescriptorProto({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.inputType != null) {
                message.inputType = data.inputType;
            }
            if (data.outputType != null) {
                message.outputType = data.outputType;
            }
            if (data.options != null) {
                message.options = MethodOptions.fromObject(data.options);
            }
            if (data.clientStreaming != null) {
                message.clientStreaming = data.clientStreaming;
            }
            if (data.serverStreaming != null) {
                message.serverStreaming = data.serverStreaming;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                inputType?: string;
                outputType?: string;
                options?: ReturnType<typeof MethodOptions.prototype.toObject>;
                clientStreaming?: boolean;
                serverStreaming?: boolean;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.inputType != null) {
                data.inputType = this.inputType;
            }
            if (this.outputType != null) {
                data.outputType = this.outputType;
            }
            if (this.options != null) {
                data.options = this.options.toObject();
            }
            if (this.clientStreaming != null) {
                data.clientStreaming = this.clientStreaming;
            }
            if (this.serverStreaming != null) {
                data.serverStreaming = this.serverStreaming;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasName && this.name.length)
                writer.writeString(1, this.name);
            if (this.hasInputType && this.inputType.length)
                writer.writeString(2, this.inputType);
            if (this.hasOutputType && this.outputType.length)
                writer.writeString(3, this.outputType);
            if (this.hasOptions)
                writer.writeMessage(4, this.options, () => this.options.serialize(writer));
            if (this.hasClientStreaming)
                writer.writeBool(5, this.clientStreaming);
            if (this.hasServerStreaming)
                writer.writeBool(6, this.serverStreaming);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MethodDescriptorProto {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MethodDescriptorProto();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.inputType = reader.readString();
                        break;
                    case 3:
                        message.outputType = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.options, () => message.options = MethodOptions.deserialize(reader));
                        break;
                    case 5:
                        message.clientStreaming = reader.readBool();
                        break;
                    case 6:
                        message.serverStreaming = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MethodDescriptorProto {
            return MethodDescriptorProto.deserialize(bytes);
        }
    }
    export class FileOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            javaPackage?: string;
            javaOuterClassname?: string;
            javaMultipleFiles?: boolean;
            /** @deprecated*/
            javaGenerateEqualsAndHash?: boolean;
            javaStringCheckUtf8?: boolean;
            optimizeFor?: FileOptions.OptimizeMode;
            goPackage?: string;
            ccGenericServices?: boolean;
            javaGenericServices?: boolean;
            pyGenericServices?: boolean;
            deprecated?: boolean;
            ccEnableArenas?: boolean;
            objcClassPrefix?: string;
            csharpNamespace?: string;
            swiftPrefix?: string;
            phpClassPrefix?: string;
            phpNamespace?: string;
            phpMetadataNamespace?: string;
            rubyPackage?: string;
            features?: FeatureSet;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("javaPackage" in data && data.javaPackage != undefined) {
                    this.javaPackage = data.javaPackage;
                }
                if ("javaOuterClassname" in data && data.javaOuterClassname != undefined) {
                    this.javaOuterClassname = data.javaOuterClassname;
                }
                if ("javaMultipleFiles" in data && data.javaMultipleFiles != undefined) {
                    this.javaMultipleFiles = data.javaMultipleFiles;
                }
                if ("javaGenerateEqualsAndHash" in data && data.javaGenerateEqualsAndHash != undefined) {
                    this.javaGenerateEqualsAndHash = data.javaGenerateEqualsAndHash;
                }
                if ("javaStringCheckUtf8" in data && data.javaStringCheckUtf8 != undefined) {
                    this.javaStringCheckUtf8 = data.javaStringCheckUtf8;
                }
                if ("optimizeFor" in data && data.optimizeFor != undefined) {
                    this.optimizeFor = data.optimizeFor;
                }
                if ("goPackage" in data && data.goPackage != undefined) {
                    this.goPackage = data.goPackage;
                }
                if ("ccGenericServices" in data && data.ccGenericServices != undefined) {
                    this.ccGenericServices = data.ccGenericServices;
                }
                if ("javaGenericServices" in data && data.javaGenericServices != undefined) {
                    this.javaGenericServices = data.javaGenericServices;
                }
                if ("pyGenericServices" in data && data.pyGenericServices != undefined) {
                    this.pyGenericServices = data.pyGenericServices;
                }
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("ccEnableArenas" in data && data.ccEnableArenas != undefined) {
                    this.ccEnableArenas = data.ccEnableArenas;
                }
                if ("objcClassPrefix" in data && data.objcClassPrefix != undefined) {
                    this.objcClassPrefix = data.objcClassPrefix;
                }
                if ("csharpNamespace" in data && data.csharpNamespace != undefined) {
                    this.csharpNamespace = data.csharpNamespace;
                }
                if ("swiftPrefix" in data && data.swiftPrefix != undefined) {
                    this.swiftPrefix = data.swiftPrefix;
                }
                if ("phpClassPrefix" in data && data.phpClassPrefix != undefined) {
                    this.phpClassPrefix = data.phpClassPrefix;
                }
                if ("phpNamespace" in data && data.phpNamespace != undefined) {
                    this.phpNamespace = data.phpNamespace;
                }
                if ("phpMetadataNamespace" in data && data.phpMetadataNamespace != undefined) {
                    this.phpMetadataNamespace = data.phpMetadataNamespace;
                }
                if ("rubyPackage" in data && data.rubyPackage != undefined) {
                    this.rubyPackage = data.rubyPackage;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get javaPackage() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set javaPackage(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasJavaPackage() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get javaOuterClassname() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set javaOuterClassname(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get hasJavaOuterClassname() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get javaMultipleFiles() {
            return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
        }
        set javaMultipleFiles(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get hasJavaMultipleFiles() {
            return pb_1.Message.getField(this, 10) != null;
        }
        /** @deprecated*/
        get javaGenerateEqualsAndHash() {
            return pb_1.Message.getFieldWithDefault(this, 20, false) as boolean;
        }
        /** @deprecated*/
        set javaGenerateEqualsAndHash(value: boolean) {
            pb_1.Message.setField(this, 20, value);
        }
        /** @deprecated*/
        get hasJavaGenerateEqualsAndHash() {
            return pb_1.Message.getField(this, 20) != null;
        }
        get javaStringCheckUtf8() {
            return pb_1.Message.getFieldWithDefault(this, 27, false) as boolean;
        }
        set javaStringCheckUtf8(value: boolean) {
            pb_1.Message.setField(this, 27, value);
        }
        get hasJavaStringCheckUtf8() {
            return pb_1.Message.getField(this, 27) != null;
        }
        get optimizeFor() {
            return pb_1.Message.getFieldWithDefault(this, 9, FileOptions.OptimizeMode.SPEED) as FileOptions.OptimizeMode;
        }
        set optimizeFor(value: FileOptions.OptimizeMode) {
            pb_1.Message.setField(this, 9, value);
        }
        get hasOptimizeFor() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get goPackage() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set goPackage(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        get hasGoPackage() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get ccGenericServices() {
            return pb_1.Message.getFieldWithDefault(this, 16, false) as boolean;
        }
        set ccGenericServices(value: boolean) {
            pb_1.Message.setField(this, 16, value);
        }
        get hasCcGenericServices() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get javaGenericServices() {
            return pb_1.Message.getFieldWithDefault(this, 17, false) as boolean;
        }
        set javaGenericServices(value: boolean) {
            pb_1.Message.setField(this, 17, value);
        }
        get hasJavaGenericServices() {
            return pb_1.Message.getField(this, 17) != null;
        }
        get pyGenericServices() {
            return pb_1.Message.getFieldWithDefault(this, 18, false) as boolean;
        }
        set pyGenericServices(value: boolean) {
            pb_1.Message.setField(this, 18, value);
        }
        get hasPyGenericServices() {
            return pb_1.Message.getField(this, 18) != null;
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 23, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 23, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 23) != null;
        }
        get ccEnableArenas() {
            return pb_1.Message.getFieldWithDefault(this, 31, true) as boolean;
        }
        set ccEnableArenas(value: boolean) {
            pb_1.Message.setField(this, 31, value);
        }
        get hasCcEnableArenas() {
            return pb_1.Message.getField(this, 31) != null;
        }
        get objcClassPrefix() {
            return pb_1.Message.getFieldWithDefault(this, 36, "") as string;
        }
        set objcClassPrefix(value: string) {
            pb_1.Message.setField(this, 36, value);
        }
        get hasObjcClassPrefix() {
            return pb_1.Message.getField(this, 36) != null;
        }
        get csharpNamespace() {
            return pb_1.Message.getFieldWithDefault(this, 37, "") as string;
        }
        set csharpNamespace(value: string) {
            pb_1.Message.setField(this, 37, value);
        }
        get hasCsharpNamespace() {
            return pb_1.Message.getField(this, 37) != null;
        }
        get swiftPrefix() {
            return pb_1.Message.getFieldWithDefault(this, 39, "") as string;
        }
        set swiftPrefix(value: string) {
            pb_1.Message.setField(this, 39, value);
        }
        get hasSwiftPrefix() {
            return pb_1.Message.getField(this, 39) != null;
        }
        get phpClassPrefix() {
            return pb_1.Message.getFieldWithDefault(this, 40, "") as string;
        }
        set phpClassPrefix(value: string) {
            pb_1.Message.setField(this, 40, value);
        }
        get hasPhpClassPrefix() {
            return pb_1.Message.getField(this, 40) != null;
        }
        get phpNamespace() {
            return pb_1.Message.getFieldWithDefault(this, 41, "") as string;
        }
        set phpNamespace(value: string) {
            pb_1.Message.setField(this, 41, value);
        }
        get hasPhpNamespace() {
            return pb_1.Message.getField(this, 41) != null;
        }
        get phpMetadataNamespace() {
            return pb_1.Message.getFieldWithDefault(this, 44, "") as string;
        }
        set phpMetadataNamespace(value: string) {
            pb_1.Message.setField(this, 44, value);
        }
        get hasPhpMetadataNamespace() {
            return pb_1.Message.getField(this, 44) != null;
        }
        get rubyPackage() {
            return pb_1.Message.getFieldWithDefault(this, 45, "") as string;
        }
        set rubyPackage(value: string) {
            pb_1.Message.setField(this, 45, value);
        }
        get hasRubyPackage() {
            return pb_1.Message.getField(this, 45) != null;
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 50) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 50, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 50) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            javaPackage?: string;
            javaOuterClassname?: string;
            javaMultipleFiles?: boolean;
            javaGenerateEqualsAndHash?: boolean;
            javaStringCheckUtf8?: boolean;
            optimizeFor?: FileOptions.OptimizeMode;
            goPackage?: string;
            ccGenericServices?: boolean;
            javaGenericServices?: boolean;
            pyGenericServices?: boolean;
            deprecated?: boolean;
            ccEnableArenas?: boolean;
            objcClassPrefix?: string;
            csharpNamespace?: string;
            swiftPrefix?: string;
            phpClassPrefix?: string;
            phpNamespace?: string;
            phpMetadataNamespace?: string;
            rubyPackage?: string;
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): FileOptions {
            const message = new FileOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.javaPackage != null) {
                message.javaPackage = data.javaPackage;
            }
            if (data.javaOuterClassname != null) {
                message.javaOuterClassname = data.javaOuterClassname;
            }
            if (data.javaMultipleFiles != null) {
                message.javaMultipleFiles = data.javaMultipleFiles;
            }
            if (data.javaGenerateEqualsAndHash != null) {
                message.javaGenerateEqualsAndHash = data.javaGenerateEqualsAndHash;
            }
            if (data.javaStringCheckUtf8 != null) {
                message.javaStringCheckUtf8 = data.javaStringCheckUtf8;
            }
            if (data.optimizeFor != null) {
                message.optimizeFor = data.optimizeFor;
            }
            if (data.goPackage != null) {
                message.goPackage = data.goPackage;
            }
            if (data.ccGenericServices != null) {
                message.ccGenericServices = data.ccGenericServices;
            }
            if (data.javaGenericServices != null) {
                message.javaGenericServices = data.javaGenericServices;
            }
            if (data.pyGenericServices != null) {
                message.pyGenericServices = data.pyGenericServices;
            }
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.ccEnableArenas != null) {
                message.ccEnableArenas = data.ccEnableArenas;
            }
            if (data.objcClassPrefix != null) {
                message.objcClassPrefix = data.objcClassPrefix;
            }
            if (data.csharpNamespace != null) {
                message.csharpNamespace = data.csharpNamespace;
            }
            if (data.swiftPrefix != null) {
                message.swiftPrefix = data.swiftPrefix;
            }
            if (data.phpClassPrefix != null) {
                message.phpClassPrefix = data.phpClassPrefix;
            }
            if (data.phpNamespace != null) {
                message.phpNamespace = data.phpNamespace;
            }
            if (data.phpMetadataNamespace != null) {
                message.phpMetadataNamespace = data.phpMetadataNamespace;
            }
            if (data.rubyPackage != null) {
                message.rubyPackage = data.rubyPackage;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            return message;
        }
        toObject() {
            const data: {
                javaPackage?: string;
                javaOuterClassname?: string;
                javaMultipleFiles?: boolean;
                javaGenerateEqualsAndHash?: boolean;
                javaStringCheckUtf8?: boolean;
                optimizeFor?: FileOptions.OptimizeMode;
                goPackage?: string;
                ccGenericServices?: boolean;
                javaGenericServices?: boolean;
                pyGenericServices?: boolean;
                deprecated?: boolean;
                ccEnableArenas?: boolean;
                objcClassPrefix?: string;
                csharpNamespace?: string;
                swiftPrefix?: string;
                phpClassPrefix?: string;
                phpNamespace?: string;
                phpMetadataNamespace?: string;
                rubyPackage?: string;
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.javaPackage != null) {
                data.javaPackage = this.javaPackage;
            }
            if (this.javaOuterClassname != null) {
                data.javaOuterClassname = this.javaOuterClassname;
            }
            if (this.javaMultipleFiles != null) {
                data.javaMultipleFiles = this.javaMultipleFiles;
            }
            if (this.javaGenerateEqualsAndHash != null) {
                data.javaGenerateEqualsAndHash = this.javaGenerateEqualsAndHash;
            }
            if (this.javaStringCheckUtf8 != null) {
                data.javaStringCheckUtf8 = this.javaStringCheckUtf8;
            }
            if (this.optimizeFor != null) {
                data.optimizeFor = this.optimizeFor;
            }
            if (this.goPackage != null) {
                data.goPackage = this.goPackage;
            }
            if (this.ccGenericServices != null) {
                data.ccGenericServices = this.ccGenericServices;
            }
            if (this.javaGenericServices != null) {
                data.javaGenericServices = this.javaGenericServices;
            }
            if (this.pyGenericServices != null) {
                data.pyGenericServices = this.pyGenericServices;
            }
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.ccEnableArenas != null) {
                data.ccEnableArenas = this.ccEnableArenas;
            }
            if (this.objcClassPrefix != null) {
                data.objcClassPrefix = this.objcClassPrefix;
            }
            if (this.csharpNamespace != null) {
                data.csharpNamespace = this.csharpNamespace;
            }
            if (this.swiftPrefix != null) {
                data.swiftPrefix = this.swiftPrefix;
            }
            if (this.phpClassPrefix != null) {
                data.phpClassPrefix = this.phpClassPrefix;
            }
            if (this.phpNamespace != null) {
                data.phpNamespace = this.phpNamespace;
            }
            if (this.phpMetadataNamespace != null) {
                data.phpMetadataNamespace = this.phpMetadataNamespace;
            }
            if (this.rubyPackage != null) {
                data.rubyPackage = this.rubyPackage;
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasJavaPackage && this.javaPackage.length)
                writer.writeString(1, this.javaPackage);
            if (this.hasJavaOuterClassname && this.javaOuterClassname.length)
                writer.writeString(8, this.javaOuterClassname);
            if (this.hasJavaMultipleFiles)
                writer.writeBool(10, this.javaMultipleFiles);
            if (this.hasJavaGenerateEqualsAndHash)
                writer.writeBool(20, this.javaGenerateEqualsAndHash);
            if (this.hasJavaStringCheckUtf8)
                writer.writeBool(27, this.javaStringCheckUtf8);
            if (this.hasOptimizeFor)
                writer.writeEnum(9, this.optimizeFor);
            if (this.hasGoPackage && this.goPackage.length)
                writer.writeString(11, this.goPackage);
            if (this.hasCcGenericServices)
                writer.writeBool(16, this.ccGenericServices);
            if (this.hasJavaGenericServices)
                writer.writeBool(17, this.javaGenericServices);
            if (this.hasPyGenericServices)
                writer.writeBool(18, this.pyGenericServices);
            if (this.hasDeprecated)
                writer.writeBool(23, this.deprecated);
            if (this.hasCcEnableArenas)
                writer.writeBool(31, this.ccEnableArenas);
            if (this.hasObjcClassPrefix && this.objcClassPrefix.length)
                writer.writeString(36, this.objcClassPrefix);
            if (this.hasCsharpNamespace && this.csharpNamespace.length)
                writer.writeString(37, this.csharpNamespace);
            if (this.hasSwiftPrefix && this.swiftPrefix.length)
                writer.writeString(39, this.swiftPrefix);
            if (this.hasPhpClassPrefix && this.phpClassPrefix.length)
                writer.writeString(40, this.phpClassPrefix);
            if (this.hasPhpNamespace && this.phpNamespace.length)
                writer.writeString(41, this.phpNamespace);
            if (this.hasPhpMetadataNamespace && this.phpMetadataNamespace.length)
                writer.writeString(44, this.phpMetadataNamespace);
            if (this.hasRubyPackage && this.rubyPackage.length)
                writer.writeString(45, this.rubyPackage);
            if (this.hasFeatures)
                writer.writeMessage(50, this.features, () => this.features.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.javaPackage = reader.readString();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.readString();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.readBool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.readBool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.readBool();
                        break;
                    case 9:
                        message.optimizeFor = reader.readEnum();
                        break;
                    case 11:
                        message.goPackage = reader.readString();
                        break;
                    case 16:
                        message.ccGenericServices = reader.readBool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.readBool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.readBool();
                        break;
                    case 23:
                        message.deprecated = reader.readBool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.readBool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.readString();
                        break;
                    case 37:
                        message.csharpNamespace = reader.readString();
                        break;
                    case 39:
                        message.swiftPrefix = reader.readString();
                        break;
                    case 40:
                        message.phpClassPrefix = reader.readString();
                        break;
                    case 41:
                        message.phpNamespace = reader.readString();
                        break;
                    case 44:
                        message.phpMetadataNamespace = reader.readString();
                        break;
                    case 45:
                        message.rubyPackage = reader.readString();
                        break;
                    case 50:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileOptions {
            return FileOptions.deserialize(bytes);
        }
    }
    export namespace FileOptions {
        export enum OptimizeMode {
            SPEED = 1,
            CODE_SIZE = 2,
            LITE_RUNTIME = 3
        }
    }
    export class MessageOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            messageSetWireFormat?: boolean;
            noStandardDescriptorAccessor?: boolean;
            deprecated?: boolean;
            mapEntry?: boolean;
            /** @deprecated*/
            deprecatedLegacyJsonFieldConflicts?: boolean;
            features?: FeatureSet;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messageSetWireFormat" in data && data.messageSetWireFormat != undefined) {
                    this.messageSetWireFormat = data.messageSetWireFormat;
                }
                if ("noStandardDescriptorAccessor" in data && data.noStandardDescriptorAccessor != undefined) {
                    this.noStandardDescriptorAccessor = data.noStandardDescriptorAccessor;
                }
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("mapEntry" in data && data.mapEntry != undefined) {
                    this.mapEntry = data.mapEntry;
                }
                if ("deprecatedLegacyJsonFieldConflicts" in data && data.deprecatedLegacyJsonFieldConflicts != undefined) {
                    this.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get messageSetWireFormat() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set messageSetWireFormat(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasMessageSetWireFormat() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get noStandardDescriptorAccessor() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set noStandardDescriptorAccessor(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasNoStandardDescriptorAccessor() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get mapEntry() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set mapEntry(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get hasMapEntry() {
            return pb_1.Message.getField(this, 7) != null;
        }
        /** @deprecated*/
        get deprecatedLegacyJsonFieldConflicts() {
            return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
        }
        /** @deprecated*/
        set deprecatedLegacyJsonFieldConflicts(value: boolean) {
            pb_1.Message.setField(this, 11, value);
        }
        /** @deprecated*/
        get hasDeprecatedLegacyJsonFieldConflicts() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 12) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 12, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            messageSetWireFormat?: boolean;
            noStandardDescriptorAccessor?: boolean;
            deprecated?: boolean;
            mapEntry?: boolean;
            deprecatedLegacyJsonFieldConflicts?: boolean;
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): MessageOptions {
            const message = new MessageOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.messageSetWireFormat != null) {
                message.messageSetWireFormat = data.messageSetWireFormat;
            }
            if (data.noStandardDescriptorAccessor != null) {
                message.noStandardDescriptorAccessor = data.noStandardDescriptorAccessor;
            }
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.mapEntry != null) {
                message.mapEntry = data.mapEntry;
            }
            if (data.deprecatedLegacyJsonFieldConflicts != null) {
                message.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            return message;
        }
        toObject() {
            const data: {
                messageSetWireFormat?: boolean;
                noStandardDescriptorAccessor?: boolean;
                deprecated?: boolean;
                mapEntry?: boolean;
                deprecatedLegacyJsonFieldConflicts?: boolean;
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.messageSetWireFormat != null) {
                data.messageSetWireFormat = this.messageSetWireFormat;
            }
            if (this.noStandardDescriptorAccessor != null) {
                data.noStandardDescriptorAccessor = this.noStandardDescriptorAccessor;
            }
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.mapEntry != null) {
                data.mapEntry = this.mapEntry;
            }
            if (this.deprecatedLegacyJsonFieldConflicts != null) {
                data.deprecatedLegacyJsonFieldConflicts = this.deprecatedLegacyJsonFieldConflicts;
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasMessageSetWireFormat)
                writer.writeBool(1, this.messageSetWireFormat);
            if (this.hasNoStandardDescriptorAccessor)
                writer.writeBool(2, this.noStandardDescriptorAccessor);
            if (this.hasDeprecated)
                writer.writeBool(3, this.deprecated);
            if (this.hasMapEntry)
                writer.writeBool(7, this.mapEntry);
            if (this.hasDeprecatedLegacyJsonFieldConflicts)
                writer.writeBool(11, this.deprecatedLegacyJsonFieldConflicts);
            if (this.hasFeatures)
                writer.writeMessage(12, this.features, () => this.features.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MessageOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MessageOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.messageSetWireFormat = reader.readBool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.readBool();
                        break;
                    case 3:
                        message.deprecated = reader.readBool();
                        break;
                    case 7:
                        message.mapEntry = reader.readBool();
                        break;
                    case 11:
                        message.deprecatedLegacyJsonFieldConflicts = reader.readBool();
                        break;
                    case 12:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MessageOptions {
            return MessageOptions.deserialize(bytes);
        }
    }
    export class FieldOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ctype?: FieldOptions.CType;
            packed?: boolean;
            jstype?: FieldOptions.JSType;
            lazy?: boolean;
            unverifiedLazy?: boolean;
            deprecated?: boolean;
            weak?: boolean;
            debugRedact?: boolean;
            retention?: FieldOptions.OptionRetention;
            targets: FieldOptions.OptionTargetType[];
            editionDefaults: FieldOptions.EditionDefault[];
            features?: FeatureSet;
            featureSupport?: FieldOptions.FeatureSupport;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [19, 20, 999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ctype" in data && data.ctype != undefined) {
                    this.ctype = data.ctype;
                }
                if ("packed" in data && data.packed != undefined) {
                    this.packed = data.packed;
                }
                if ("jstype" in data && data.jstype != undefined) {
                    this.jstype = data.jstype;
                }
                if ("lazy" in data && data.lazy != undefined) {
                    this.lazy = data.lazy;
                }
                if ("unverifiedLazy" in data && data.unverifiedLazy != undefined) {
                    this.unverifiedLazy = data.unverifiedLazy;
                }
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("weak" in data && data.weak != undefined) {
                    this.weak = data.weak;
                }
                if ("debugRedact" in data && data.debugRedact != undefined) {
                    this.debugRedact = data.debugRedact;
                }
                if ("retention" in data && data.retention != undefined) {
                    this.retention = data.retention;
                }
                this.targets = data.targets;
                this.editionDefaults = data.editionDefaults;
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("featureSupport" in data && data.featureSupport != undefined) {
                    this.featureSupport = data.featureSupport;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get ctype() {
            return pb_1.Message.getFieldWithDefault(this, 1, FieldOptions.CType.STRING) as FieldOptions.CType;
        }
        set ctype(value: FieldOptions.CType) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasCtype() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get packed() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set packed(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasPacked() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get jstype() {
            return pb_1.Message.getFieldWithDefault(this, 6, FieldOptions.JSType.JS_NORMAL) as FieldOptions.JSType;
        }
        set jstype(value: FieldOptions.JSType) {
            pb_1.Message.setField(this, 6, value);
        }
        get hasJstype() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get lazy() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set lazy(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasLazy() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get unverifiedLazy() {
            return pb_1.Message.getFieldWithDefault(this, 15, false) as boolean;
        }
        set unverifiedLazy(value: boolean) {
            pb_1.Message.setField(this, 15, value);
        }
        get hasUnverifiedLazy() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get weak() {
            return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
        }
        set weak(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get hasWeak() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get debugRedact() {
            return pb_1.Message.getFieldWithDefault(this, 16, false) as boolean;
        }
        set debugRedact(value: boolean) {
            pb_1.Message.setField(this, 16, value);
        }
        get hasDebugRedact() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get retention() {
            return pb_1.Message.getFieldWithDefault(this, 17, FieldOptions.OptionRetention.RETENTION_UNKNOWN) as FieldOptions.OptionRetention;
        }
        set retention(value: FieldOptions.OptionRetention) {
            pb_1.Message.setField(this, 17, value);
        }
        get hasRetention() {
            return pb_1.Message.getField(this, 17) != null;
        }
        get targets() {
            return pb_1.Message.getFieldWithDefault(this, 19, []) as FieldOptions.OptionTargetType[];
        }
        set targets(value: FieldOptions.OptionTargetType[]) {
            pb_1.Message.setField(this, 19, value);
        }
        get editionDefaults() {
            return pb_1.Message.getRepeatedWrapperField(this, FieldOptions.EditionDefault, 20) as FieldOptions.EditionDefault[];
        }
        set editionDefaults(value: FieldOptions.EditionDefault[]) {
            pb_1.Message.setRepeatedWrapperField(this, 20, value);
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 21) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 21, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 21) != null;
        }
        get featureSupport() {
            return pb_1.Message.getWrapperField(this, FieldOptions.FeatureSupport, 22) as FieldOptions.FeatureSupport;
        }
        set featureSupport(value: FieldOptions.FeatureSupport) {
            pb_1.Message.setWrapperField(this, 22, value);
        }
        get hasFeatureSupport() {
            return pb_1.Message.getField(this, 22) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            ctype?: FieldOptions.CType;
            packed?: boolean;
            jstype?: FieldOptions.JSType;
            lazy?: boolean;
            unverifiedLazy?: boolean;
            deprecated?: boolean;
            weak?: boolean;
            debugRedact?: boolean;
            retention?: FieldOptions.OptionRetention;
            targets: FieldOptions.OptionTargetType[];
            editionDefaults?: ReturnType<typeof FieldOptions.EditionDefault.prototype.toObject>[];
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            featureSupport?: ReturnType<typeof FieldOptions.FeatureSupport.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): FieldOptions {
            const message = new FieldOptions({
                targets: data.targets,
                editionDefaults: data.editionDefaults.map(item => FieldOptions.EditionDefault.fromObject(item)),
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.ctype != null) {
                message.ctype = data.ctype;
            }
            if (data.packed != null) {
                message.packed = data.packed;
            }
            if (data.jstype != null) {
                message.jstype = data.jstype;
            }
            if (data.lazy != null) {
                message.lazy = data.lazy;
            }
            if (data.unverifiedLazy != null) {
                message.unverifiedLazy = data.unverifiedLazy;
            }
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.weak != null) {
                message.weak = data.weak;
            }
            if (data.debugRedact != null) {
                message.debugRedact = data.debugRedact;
            }
            if (data.retention != null) {
                message.retention = data.retention;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            if (data.featureSupport != null) {
                message.featureSupport = FieldOptions.FeatureSupport.fromObject(data.featureSupport);
            }
            return message;
        }
        toObject() {
            const data: {
                ctype?: FieldOptions.CType;
                packed?: boolean;
                jstype?: FieldOptions.JSType;
                lazy?: boolean;
                unverifiedLazy?: boolean;
                deprecated?: boolean;
                weak?: boolean;
                debugRedact?: boolean;
                retention?: FieldOptions.OptionRetention;
                targets: FieldOptions.OptionTargetType[];
                editionDefaults?: ReturnType<typeof FieldOptions.EditionDefault.prototype.toObject>[];
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                featureSupport?: ReturnType<typeof FieldOptions.FeatureSupport.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {
                targets: this.targets
            };
            if (this.ctype != null) {
                data.ctype = this.ctype;
            }
            if (this.packed != null) {
                data.packed = this.packed;
            }
            if (this.jstype != null) {
                data.jstype = this.jstype;
            }
            if (this.lazy != null) {
                data.lazy = this.lazy;
            }
            if (this.unverifiedLazy != null) {
                data.unverifiedLazy = this.unverifiedLazy;
            }
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.weak != null) {
                data.weak = this.weak;
            }
            if (this.debugRedact != null) {
                data.debugRedact = this.debugRedact;
            }
            if (this.retention != null) {
                data.retention = this.retention;
            }
            if (this.editionDefaults != null) {
                data.editionDefaults = this.editionDefaults.map((item: FieldOptions.EditionDefault) => item.toObject());
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.featureSupport != null) {
                data.featureSupport = this.featureSupport.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasCtype)
                writer.writeEnum(1, this.ctype);
            if (this.hasPacked)
                writer.writeBool(2, this.packed);
            if (this.hasJstype)
                writer.writeEnum(6, this.jstype);
            if (this.hasLazy)
                writer.writeBool(5, this.lazy);
            if (this.hasUnverifiedLazy)
                writer.writeBool(15, this.unverifiedLazy);
            if (this.hasDeprecated)
                writer.writeBool(3, this.deprecated);
            if (this.hasWeak)
                writer.writeBool(10, this.weak);
            if (this.hasDebugRedact)
                writer.writeBool(16, this.debugRedact);
            if (this.hasRetention)
                writer.writeEnum(17, this.retention);
            if (this.targets.length)
                writer.writeRepeatedEnum(19, this.targets);
            if (this.editionDefaults.length)
                writer.writeRepeatedMessage(20, this.editionDefaults, (item: FieldOptions.EditionDefault) => item.serialize(writer));
            if (this.hasFeatures)
                writer.writeMessage(21, this.features, () => this.features.serialize(writer));
            if (this.hasFeatureSupport)
                writer.writeMessage(22, this.featureSupport, () => this.featureSupport.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FieldOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FieldOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ctype = reader.readEnum();
                        break;
                    case 2:
                        message.packed = reader.readBool();
                        break;
                    case 6:
                        message.jstype = reader.readEnum();
                        break;
                    case 5:
                        message.lazy = reader.readBool();
                        break;
                    case 15:
                        message.unverifiedLazy = reader.readBool();
                        break;
                    case 3:
                        message.deprecated = reader.readBool();
                        break;
                    case 10:
                        message.weak = reader.readBool();
                        break;
                    case 16:
                        message.debugRedact = reader.readBool();
                        break;
                    case 17:
                        message.retention = reader.readEnum();
                        break;
                    case 19:
                        pb_1.Message.addToRepeatedField(message, 19, reader.readEnum());
                        break;
                    case 20:
                        reader.readMessage(message.editionDefaults, () => pb_1.Message.addToRepeatedWrapperField(message, 20, FieldOptions.EditionDefault.deserialize(reader), FieldOptions.EditionDefault));
                        break;
                    case 21:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 22:
                        reader.readMessage(message.featureSupport, () => message.featureSupport = FieldOptions.FeatureSupport.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FieldOptions {
            return FieldOptions.deserialize(bytes);
        }
    }
    export namespace FieldOptions {
        export enum CType {
            STRING = 0,
            CORD = 1,
            STRING_PIECE = 2
        }
        export enum JSType {
            JS_NORMAL = 0,
            JS_STRING = 1,
            JS_NUMBER = 2
        }
        export enum OptionRetention {
            RETENTION_UNKNOWN = 0,
            RETENTION_RUNTIME = 1,
            RETENTION_SOURCE = 2
        }
        export enum OptionTargetType {
            TARGET_TYPE_UNKNOWN = 0,
            TARGET_TYPE_FILE = 1,
            TARGET_TYPE_EXTENSION_RANGE = 2,
            TARGET_TYPE_MESSAGE = 3,
            TARGET_TYPE_FIELD = 4,
            TARGET_TYPE_ONEOF = 5,
            TARGET_TYPE_ENUM = 6,
            TARGET_TYPE_ENUM_ENTRY = 7,
            TARGET_TYPE_SERVICE = 8,
            TARGET_TYPE_METHOD = 9
        }
        export class EditionDefault extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                edition?: Edition;
                value?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("edition" in data && data.edition != undefined) {
                        this.edition = data.edition;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get edition() {
                return pb_1.Message.getFieldWithDefault(this, 3, Edition.EDITION_UNKNOWN) as Edition;
            }
            set edition(value: Edition) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasEdition() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set value(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasValue() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                edition?: Edition;
                value?: string;
            }): EditionDefault {
                const message = new EditionDefault({});
                if (data.edition != null) {
                    message.edition = data.edition;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    edition?: Edition;
                    value?: string;
                } = {};
                if (this.edition != null) {
                    data.edition = this.edition;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasEdition)
                    writer.writeEnum(3, this.edition);
                if (this.hasValue && this.value.length)
                    writer.writeString(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EditionDefault {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EditionDefault();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 3:
                            message.edition = reader.readEnum();
                            break;
                        case 2:
                            message.value = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EditionDefault {
                return EditionDefault.deserialize(bytes);
            }
        }
        export class FeatureSupport extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                editionIntroduced?: Edition;
                editionDeprecated?: Edition;
                deprecationWarning?: string;
                editionRemoved?: Edition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("editionIntroduced" in data && data.editionIntroduced != undefined) {
                        this.editionIntroduced = data.editionIntroduced;
                    }
                    if ("editionDeprecated" in data && data.editionDeprecated != undefined) {
                        this.editionDeprecated = data.editionDeprecated;
                    }
                    if ("deprecationWarning" in data && data.deprecationWarning != undefined) {
                        this.deprecationWarning = data.deprecationWarning;
                    }
                    if ("editionRemoved" in data && data.editionRemoved != undefined) {
                        this.editionRemoved = data.editionRemoved;
                    }
                }
            }
            get editionIntroduced() {
                return pb_1.Message.getFieldWithDefault(this, 1, Edition.EDITION_UNKNOWN) as Edition;
            }
            set editionIntroduced(value: Edition) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasEditionIntroduced() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get editionDeprecated() {
                return pb_1.Message.getFieldWithDefault(this, 2, Edition.EDITION_UNKNOWN) as Edition;
            }
            set editionDeprecated(value: Edition) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasEditionDeprecated() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get deprecationWarning() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set deprecationWarning(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasDeprecationWarning() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get editionRemoved() {
                return pb_1.Message.getFieldWithDefault(this, 4, Edition.EDITION_UNKNOWN) as Edition;
            }
            set editionRemoved(value: Edition) {
                pb_1.Message.setField(this, 4, value);
            }
            get hasEditionRemoved() {
                return pb_1.Message.getField(this, 4) != null;
            }
            static fromObject(data: {
                editionIntroduced?: Edition;
                editionDeprecated?: Edition;
                deprecationWarning?: string;
                editionRemoved?: Edition;
            }): FeatureSupport {
                const message = new FeatureSupport({});
                if (data.editionIntroduced != null) {
                    message.editionIntroduced = data.editionIntroduced;
                }
                if (data.editionDeprecated != null) {
                    message.editionDeprecated = data.editionDeprecated;
                }
                if (data.deprecationWarning != null) {
                    message.deprecationWarning = data.deprecationWarning;
                }
                if (data.editionRemoved != null) {
                    message.editionRemoved = data.editionRemoved;
                }
                return message;
            }
            toObject() {
                const data: {
                    editionIntroduced?: Edition;
                    editionDeprecated?: Edition;
                    deprecationWarning?: string;
                    editionRemoved?: Edition;
                } = {};
                if (this.editionIntroduced != null) {
                    data.editionIntroduced = this.editionIntroduced;
                }
                if (this.editionDeprecated != null) {
                    data.editionDeprecated = this.editionDeprecated;
                }
                if (this.deprecationWarning != null) {
                    data.deprecationWarning = this.deprecationWarning;
                }
                if (this.editionRemoved != null) {
                    data.editionRemoved = this.editionRemoved;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasEditionIntroduced)
                    writer.writeEnum(1, this.editionIntroduced);
                if (this.hasEditionDeprecated)
                    writer.writeEnum(2, this.editionDeprecated);
                if (this.hasDeprecationWarning && this.deprecationWarning.length)
                    writer.writeString(3, this.deprecationWarning);
                if (this.hasEditionRemoved)
                    writer.writeEnum(4, this.editionRemoved);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeatureSupport {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FeatureSupport();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.editionIntroduced = reader.readEnum();
                            break;
                        case 2:
                            message.editionDeprecated = reader.readEnum();
                            break;
                        case 3:
                            message.deprecationWarning = reader.readString();
                            break;
                        case 4:
                            message.editionRemoved = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): FeatureSupport {
                return FeatureSupport.deserialize(bytes);
            }
        }
    }
    export class OneofOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            features?: FeatureSet;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 1) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): OneofOptions {
            const message = new OneofOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            return message;
        }
        toObject() {
            const data: {
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasFeatures)
                writer.writeMessage(1, this.features, () => this.features.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OneofOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OneofOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OneofOptions {
            return OneofOptions.deserialize(bytes);
        }
    }
    export class EnumOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            allowAlias?: boolean;
            deprecated?: boolean;
            /** @deprecated*/
            deprecatedLegacyJsonFieldConflicts?: boolean;
            features?: FeatureSet;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("allowAlias" in data && data.allowAlias != undefined) {
                    this.allowAlias = data.allowAlias;
                }
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("deprecatedLegacyJsonFieldConflicts" in data && data.deprecatedLegacyJsonFieldConflicts != undefined) {
                    this.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get allowAlias() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set allowAlias(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasAllowAlias() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 3) != null;
        }
        /** @deprecated*/
        get deprecatedLegacyJsonFieldConflicts() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        /** @deprecated*/
        set deprecatedLegacyJsonFieldConflicts(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        /** @deprecated*/
        get hasDeprecatedLegacyJsonFieldConflicts() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 7) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            allowAlias?: boolean;
            deprecated?: boolean;
            deprecatedLegacyJsonFieldConflicts?: boolean;
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): EnumOptions {
            const message = new EnumOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.allowAlias != null) {
                message.allowAlias = data.allowAlias;
            }
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.deprecatedLegacyJsonFieldConflicts != null) {
                message.deprecatedLegacyJsonFieldConflicts = data.deprecatedLegacyJsonFieldConflicts;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            return message;
        }
        toObject() {
            const data: {
                allowAlias?: boolean;
                deprecated?: boolean;
                deprecatedLegacyJsonFieldConflicts?: boolean;
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.allowAlias != null) {
                data.allowAlias = this.allowAlias;
            }
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.deprecatedLegacyJsonFieldConflicts != null) {
                data.deprecatedLegacyJsonFieldConflicts = this.deprecatedLegacyJsonFieldConflicts;
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasAllowAlias)
                writer.writeBool(2, this.allowAlias);
            if (this.hasDeprecated)
                writer.writeBool(3, this.deprecated);
            if (this.hasDeprecatedLegacyJsonFieldConflicts)
                writer.writeBool(6, this.deprecatedLegacyJsonFieldConflicts);
            if (this.hasFeatures)
                writer.writeMessage(7, this.features, () => this.features.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.allowAlias = reader.readBool();
                        break;
                    case 3:
                        message.deprecated = reader.readBool();
                        break;
                    case 6:
                        message.deprecatedLegacyJsonFieldConflicts = reader.readBool();
                        break;
                    case 7:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EnumOptions {
            return EnumOptions.deserialize(bytes);
        }
    }
    export class EnumValueOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            deprecated?: boolean;
            features?: FeatureSet;
            debugRedact?: boolean;
            featureSupport?: FieldOptions.FeatureSupport;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("debugRedact" in data && data.debugRedact != undefined) {
                    this.debugRedact = data.debugRedact;
                }
                if ("featureSupport" in data && data.featureSupport != undefined) {
                    this.featureSupport = data.featureSupport;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 2) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get debugRedact() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set debugRedact(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasDebugRedact() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get featureSupport() {
            return pb_1.Message.getWrapperField(this, FieldOptions.FeatureSupport, 4) as FieldOptions.FeatureSupport;
        }
        set featureSupport(value: FieldOptions.FeatureSupport) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get hasFeatureSupport() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            deprecated?: boolean;
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            debugRedact?: boolean;
            featureSupport?: ReturnType<typeof FieldOptions.FeatureSupport.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): EnumValueOptions {
            const message = new EnumValueOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            if (data.debugRedact != null) {
                message.debugRedact = data.debugRedact;
            }
            if (data.featureSupport != null) {
                message.featureSupport = FieldOptions.FeatureSupport.fromObject(data.featureSupport);
            }
            return message;
        }
        toObject() {
            const data: {
                deprecated?: boolean;
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                debugRedact?: boolean;
                featureSupport?: ReturnType<typeof FieldOptions.FeatureSupport.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.debugRedact != null) {
                data.debugRedact = this.debugRedact;
            }
            if (this.featureSupport != null) {
                data.featureSupport = this.featureSupport.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasDeprecated)
                writer.writeBool(1, this.deprecated);
            if (this.hasFeatures)
                writer.writeMessage(2, this.features, () => this.features.serialize(writer));
            if (this.hasDebugRedact)
                writer.writeBool(3, this.debugRedact);
            if (this.hasFeatureSupport)
                writer.writeMessage(4, this.featureSupport, () => this.featureSupport.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EnumValueOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EnumValueOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.deprecated = reader.readBool();
                        break;
                    case 2:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 3:
                        message.debugRedact = reader.readBool();
                        break;
                    case 4:
                        reader.readMessage(message.featureSupport, () => message.featureSupport = FieldOptions.FeatureSupport.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EnumValueOptions {
            return EnumValueOptions.deserialize(bytes);
        }
    }
    export class ServiceOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            features?: FeatureSet;
            deprecated?: boolean;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 34) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 34, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 34) != null;
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 33, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 33, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 33) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            deprecated?: boolean;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): ServiceOptions {
            const message = new ServiceOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            return message;
        }
        toObject() {
            const data: {
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                deprecated?: boolean;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasFeatures)
                writer.writeMessage(34, this.features, () => this.features.serialize(writer));
            if (this.hasDeprecated)
                writer.writeBool(33, this.deprecated);
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServiceOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ServiceOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 34:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 33:
                        message.deprecated = reader.readBool();
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ServiceOptions {
            return ServiceOptions.deserialize(bytes);
        }
    }
    export class MethodOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            deprecated?: boolean;
            idempotencyLevel?: MethodOptions.IdempotencyLevel;
            features?: FeatureSet;
            uninterpretedOption: UninterpretedOption[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [999], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("deprecated" in data && data.deprecated != undefined) {
                    this.deprecated = data.deprecated;
                }
                if ("idempotencyLevel" in data && data.idempotencyLevel != undefined) {
                    this.idempotencyLevel = data.idempotencyLevel;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
                this.uninterpretedOption = data.uninterpretedOption;
            }
        }
        get deprecated() {
            return pb_1.Message.getFieldWithDefault(this, 33, false) as boolean;
        }
        set deprecated(value: boolean) {
            pb_1.Message.setField(this, 33, value);
        }
        get hasDeprecated() {
            return pb_1.Message.getField(this, 33) != null;
        }
        get idempotencyLevel() {
            return pb_1.Message.getFieldWithDefault(this, 34, MethodOptions.IdempotencyLevel.IDEMPOTENCY_UNKNOWN) as MethodOptions.IdempotencyLevel;
        }
        set idempotencyLevel(value: MethodOptions.IdempotencyLevel) {
            pb_1.Message.setField(this, 34, value);
        }
        get hasIdempotencyLevel() {
            return pb_1.Message.getField(this, 34) != null;
        }
        get features() {
            return pb_1.Message.getWrapperField(this, FeatureSet, 35) as FeatureSet;
        }
        set features(value: FeatureSet) {
            pb_1.Message.setWrapperField(this, 35, value);
        }
        get hasFeatures() {
            return pb_1.Message.getField(this, 35) != null;
        }
        get uninterpretedOption() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption, 999) as UninterpretedOption[];
        }
        set uninterpretedOption(value: UninterpretedOption[]) {
            pb_1.Message.setRepeatedWrapperField(this, 999, value);
        }
        static fromObject(data: {
            deprecated?: boolean;
            idempotencyLevel?: MethodOptions.IdempotencyLevel;
            features?: ReturnType<typeof FeatureSet.prototype.toObject>;
            uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
        }): MethodOptions {
            const message = new MethodOptions({
                uninterpretedOption: data.uninterpretedOption.map(item => UninterpretedOption.fromObject(item))
            });
            if (data.deprecated != null) {
                message.deprecated = data.deprecated;
            }
            if (data.idempotencyLevel != null) {
                message.idempotencyLevel = data.idempotencyLevel;
            }
            if (data.features != null) {
                message.features = FeatureSet.fromObject(data.features);
            }
            return message;
        }
        toObject() {
            const data: {
                deprecated?: boolean;
                idempotencyLevel?: MethodOptions.IdempotencyLevel;
                features?: ReturnType<typeof FeatureSet.prototype.toObject>;
                uninterpretedOption?: ReturnType<typeof UninterpretedOption.prototype.toObject>[];
            } = {};
            if (this.deprecated != null) {
                data.deprecated = this.deprecated;
            }
            if (this.idempotencyLevel != null) {
                data.idempotencyLevel = this.idempotencyLevel;
            }
            if (this.features != null) {
                data.features = this.features.toObject();
            }
            if (this.uninterpretedOption != null) {
                data.uninterpretedOption = this.uninterpretedOption.map((item: UninterpretedOption) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasDeprecated)
                writer.writeBool(33, this.deprecated);
            if (this.hasIdempotencyLevel)
                writer.writeEnum(34, this.idempotencyLevel);
            if (this.hasFeatures)
                writer.writeMessage(35, this.features, () => this.features.serialize(writer));
            if (this.uninterpretedOption.length)
                writer.writeRepeatedMessage(999, this.uninterpretedOption, (item: UninterpretedOption) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MethodOptions {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MethodOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 33:
                        message.deprecated = reader.readBool();
                        break;
                    case 34:
                        message.idempotencyLevel = reader.readEnum();
                        break;
                    case 35:
                        reader.readMessage(message.features, () => message.features = FeatureSet.deserialize(reader));
                        break;
                    case 999:
                        reader.readMessage(message.uninterpretedOption, () => pb_1.Message.addToRepeatedWrapperField(message, 999, UninterpretedOption.deserialize(reader), UninterpretedOption));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MethodOptions {
            return MethodOptions.deserialize(bytes);
        }
    }
    export namespace MethodOptions {
        export enum IdempotencyLevel {
            IDEMPOTENCY_UNKNOWN = 0,
            NO_SIDE_EFFECTS = 1,
            IDEMPOTENT = 2
        }
    }
    export class UninterpretedOption extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name: UninterpretedOption.NamePart[];
            identifierValue?: string;
            positiveIntValue?: number;
            negativeIntValue?: number;
            doubleValue?: number;
            stringValue?: Uint8Array;
            aggregateValue?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.name = data.name;
                if ("identifierValue" in data && data.identifierValue != undefined) {
                    this.identifierValue = data.identifierValue;
                }
                if ("positiveIntValue" in data && data.positiveIntValue != undefined) {
                    this.positiveIntValue = data.positiveIntValue;
                }
                if ("negativeIntValue" in data && data.negativeIntValue != undefined) {
                    this.negativeIntValue = data.negativeIntValue;
                }
                if ("doubleValue" in data && data.doubleValue != undefined) {
                    this.doubleValue = data.doubleValue;
                }
                if ("stringValue" in data && data.stringValue != undefined) {
                    this.stringValue = data.stringValue;
                }
                if ("aggregateValue" in data && data.aggregateValue != undefined) {
                    this.aggregateValue = data.aggregateValue;
                }
            }
        }
        get name() {
            return pb_1.Message.getRepeatedWrapperField(this, UninterpretedOption.NamePart, 2) as UninterpretedOption.NamePart[];
        }
        set name(value: UninterpretedOption.NamePart[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get identifierValue() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set identifierValue(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasIdentifierValue() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get positiveIntValue() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set positiveIntValue(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get hasPositiveIntValue() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get negativeIntValue() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set negativeIntValue(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasNegativeIntValue() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get doubleValue() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set doubleValue(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get hasDoubleValue() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get stringValue() {
            return pb_1.Message.getFieldWithDefault(this, 7, new Uint8Array(0)) as Uint8Array;
        }
        set stringValue(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get hasStringValue() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get aggregateValue() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set aggregateValue(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get hasAggregateValue() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            name?: ReturnType<typeof UninterpretedOption.NamePart.prototype.toObject>[];
            identifierValue?: string;
            positiveIntValue?: number;
            negativeIntValue?: number;
            doubleValue?: number;
            stringValue?: Uint8Array;
            aggregateValue?: string;
        }): UninterpretedOption {
            const message = new UninterpretedOption({
                name: data.name.map(item => UninterpretedOption.NamePart.fromObject(item))
            });
            if (data.identifierValue != null) {
                message.identifierValue = data.identifierValue;
            }
            if (data.positiveIntValue != null) {
                message.positiveIntValue = data.positiveIntValue;
            }
            if (data.negativeIntValue != null) {
                message.negativeIntValue = data.negativeIntValue;
            }
            if (data.doubleValue != null) {
                message.doubleValue = data.doubleValue;
            }
            if (data.stringValue != null) {
                message.stringValue = data.stringValue;
            }
            if (data.aggregateValue != null) {
                message.aggregateValue = data.aggregateValue;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: ReturnType<typeof UninterpretedOption.NamePart.prototype.toObject>[];
                identifierValue?: string;
                positiveIntValue?: number;
                negativeIntValue?: number;
                doubleValue?: number;
                stringValue?: Uint8Array;
                aggregateValue?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name.map((item: UninterpretedOption.NamePart) => item.toObject());
            }
            if (this.identifierValue != null) {
                data.identifierValue = this.identifierValue;
            }
            if (this.positiveIntValue != null) {
                data.positiveIntValue = this.positiveIntValue;
            }
            if (this.negativeIntValue != null) {
                data.negativeIntValue = this.negativeIntValue;
            }
            if (this.doubleValue != null) {
                data.doubleValue = this.doubleValue;
            }
            if (this.stringValue != null) {
                data.stringValue = this.stringValue;
            }
            if (this.aggregateValue != null) {
                data.aggregateValue = this.aggregateValue;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeRepeatedMessage(2, this.name, (item: UninterpretedOption.NamePart) => item.serialize(writer));
            if (this.hasIdentifierValue && this.identifierValue.length)
                writer.writeString(3, this.identifierValue);
            if (this.hasPositiveIntValue)
                writer.writeUint64(4, this.positiveIntValue);
            if (this.hasNegativeIntValue)
                writer.writeInt64(5, this.negativeIntValue);
            if (this.hasDoubleValue)
                writer.writeDouble(6, this.doubleValue);
            if (this.hasStringValue && this.stringValue.length)
                writer.writeBytes(7, this.stringValue);
            if (this.hasAggregateValue && this.aggregateValue.length)
                writer.writeString(8, this.aggregateValue);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UninterpretedOption {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UninterpretedOption();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        reader.readMessage(message.name, () => pb_1.Message.addToRepeatedWrapperField(message, 2, UninterpretedOption.NamePart.deserialize(reader), UninterpretedOption.NamePart));
                        break;
                    case 3:
                        message.identifierValue = reader.readString();
                        break;
                    case 4:
                        message.positiveIntValue = reader.readUint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.readInt64();
                        break;
                    case 6:
                        message.doubleValue = reader.readDouble();
                        break;
                    case 7:
                        message.stringValue = reader.readBytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UninterpretedOption {
            return UninterpretedOption.deserialize(bytes);
        }
    }
    export namespace UninterpretedOption {
        export class NamePart extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                namePart: string;
                isExtension: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    this.namePart = data.namePart;
                    this.isExtension = data.isExtension;
                }
            }
            get namePart() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set namePart(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get hasNamePart() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get isExtension() {
                return pb_1.Message.getField(this, 2) as boolean;
            }
            set isExtension(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasIsExtension() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                namePart?: string;
                isExtension?: boolean;
            }): NamePart {
                const message = new NamePart({
                    namePart: data.namePart,
                    isExtension: data.isExtension
                });
                return message;
            }
            toObject() {
                const data: {
                    namePart?: string;
                    isExtension?: boolean;
                } = {};
                if (this.namePart != null) {
                    data.namePart = this.namePart;
                }
                if (this.isExtension != null) {
                    data.isExtension = this.isExtension;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasNamePart && this.namePart.length)
                    writer.writeString(1, this.namePart);
                if (this.hasIsExtension)
                    writer.writeBool(2, this.isExtension);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NamePart {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NamePart();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.namePart = reader.readString();
                            break;
                        case 2:
                            message.isExtension = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): NamePart {
                return NamePart.deserialize(bytes);
            }
        }
    }
    export class FeatureSet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fieldPresence?: FeatureSet.FieldPresence;
            enumType?: FeatureSet.EnumType;
            repeatedFieldEncoding?: FeatureSet.RepeatedFieldEncoding;
            utf8Validation?: FeatureSet.Utf8Validation;
            messageEncoding?: FeatureSet.MessageEncoding;
            jsonFormat?: FeatureSet.JsonFormat;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fieldPresence" in data && data.fieldPresence != undefined) {
                    this.fieldPresence = data.fieldPresence;
                }
                if ("enumType" in data && data.enumType != undefined) {
                    this.enumType = data.enumType;
                }
                if ("repeatedFieldEncoding" in data && data.repeatedFieldEncoding != undefined) {
                    this.repeatedFieldEncoding = data.repeatedFieldEncoding;
                }
                if ("utf8Validation" in data && data.utf8Validation != undefined) {
                    this.utf8Validation = data.utf8Validation;
                }
                if ("messageEncoding" in data && data.messageEncoding != undefined) {
                    this.messageEncoding = data.messageEncoding;
                }
                if ("jsonFormat" in data && data.jsonFormat != undefined) {
                    this.jsonFormat = data.jsonFormat;
                }
            }
        }
        get fieldPresence() {
            return pb_1.Message.getFieldWithDefault(this, 1, FeatureSet.FieldPresence.FIELD_PRESENCE_UNKNOWN) as FeatureSet.FieldPresence;
        }
        set fieldPresence(value: FeatureSet.FieldPresence) {
            pb_1.Message.setField(this, 1, value);
        }
        get hasFieldPresence() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get enumType() {
            return pb_1.Message.getFieldWithDefault(this, 2, FeatureSet.EnumType.ENUM_TYPE_UNKNOWN) as FeatureSet.EnumType;
        }
        set enumType(value: FeatureSet.EnumType) {
            pb_1.Message.setField(this, 2, value);
        }
        get hasEnumType() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get repeatedFieldEncoding() {
            return pb_1.Message.getFieldWithDefault(this, 3, FeatureSet.RepeatedFieldEncoding.REPEATED_FIELD_ENCODING_UNKNOWN) as FeatureSet.RepeatedFieldEncoding;
        }
        set repeatedFieldEncoding(value: FeatureSet.RepeatedFieldEncoding) {
            pb_1.Message.setField(this, 3, value);
        }
        get hasRepeatedFieldEncoding() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get utf8Validation() {
            return pb_1.Message.getFieldWithDefault(this, 4, FeatureSet.Utf8Validation.UTF8_VALIDATION_UNKNOWN) as FeatureSet.Utf8Validation;
        }
        set utf8Validation(value: FeatureSet.Utf8Validation) {
            pb_1.Message.setField(this, 4, value);
        }
        get hasUtf8Validation() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get messageEncoding() {
            return pb_1.Message.getFieldWithDefault(this, 5, FeatureSet.MessageEncoding.MESSAGE_ENCODING_UNKNOWN) as FeatureSet.MessageEncoding;
        }
        set messageEncoding(value: FeatureSet.MessageEncoding) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasMessageEncoding() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get jsonFormat() {
            return pb_1.Message.getFieldWithDefault(this, 6, FeatureSet.JsonFormat.JSON_FORMAT_UNKNOWN) as FeatureSet.JsonFormat;
        }
        set jsonFormat(value: FeatureSet.JsonFormat) {
            pb_1.Message.setField(this, 6, value);
        }
        get hasJsonFormat() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            fieldPresence?: FeatureSet.FieldPresence;
            enumType?: FeatureSet.EnumType;
            repeatedFieldEncoding?: FeatureSet.RepeatedFieldEncoding;
            utf8Validation?: FeatureSet.Utf8Validation;
            messageEncoding?: FeatureSet.MessageEncoding;
            jsonFormat?: FeatureSet.JsonFormat;
        }): FeatureSet {
            const message = new FeatureSet({});
            if (data.fieldPresence != null) {
                message.fieldPresence = data.fieldPresence;
            }
            if (data.enumType != null) {
                message.enumType = data.enumType;
            }
            if (data.repeatedFieldEncoding != null) {
                message.repeatedFieldEncoding = data.repeatedFieldEncoding;
            }
            if (data.utf8Validation != null) {
                message.utf8Validation = data.utf8Validation;
            }
            if (data.messageEncoding != null) {
                message.messageEncoding = data.messageEncoding;
            }
            if (data.jsonFormat != null) {
                message.jsonFormat = data.jsonFormat;
            }
            return message;
        }
        toObject() {
            const data: {
                fieldPresence?: FeatureSet.FieldPresence;
                enumType?: FeatureSet.EnumType;
                repeatedFieldEncoding?: FeatureSet.RepeatedFieldEncoding;
                utf8Validation?: FeatureSet.Utf8Validation;
                messageEncoding?: FeatureSet.MessageEncoding;
                jsonFormat?: FeatureSet.JsonFormat;
            } = {};
            if (this.fieldPresence != null) {
                data.fieldPresence = this.fieldPresence;
            }
            if (this.enumType != null) {
                data.enumType = this.enumType;
            }
            if (this.repeatedFieldEncoding != null) {
                data.repeatedFieldEncoding = this.repeatedFieldEncoding;
            }
            if (this.utf8Validation != null) {
                data.utf8Validation = this.utf8Validation;
            }
            if (this.messageEncoding != null) {
                data.messageEncoding = this.messageEncoding;
            }
            if (this.jsonFormat != null) {
                data.jsonFormat = this.jsonFormat;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasFieldPresence)
                writer.writeEnum(1, this.fieldPresence);
            if (this.hasEnumType)
                writer.writeEnum(2, this.enumType);
            if (this.hasRepeatedFieldEncoding)
                writer.writeEnum(3, this.repeatedFieldEncoding);
            if (this.hasUtf8Validation)
                writer.writeEnum(4, this.utf8Validation);
            if (this.hasMessageEncoding)
                writer.writeEnum(5, this.messageEncoding);
            if (this.hasJsonFormat)
                writer.writeEnum(6, this.jsonFormat);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeatureSet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FeatureSet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.fieldPresence = reader.readEnum();
                        break;
                    case 2:
                        message.enumType = reader.readEnum();
                        break;
                    case 3:
                        message.repeatedFieldEncoding = reader.readEnum();
                        break;
                    case 4:
                        message.utf8Validation = reader.readEnum();
                        break;
                    case 5:
                        message.messageEncoding = reader.readEnum();
                        break;
                    case 6:
                        message.jsonFormat = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FeatureSet {
            return FeatureSet.deserialize(bytes);
        }
    }
    export namespace FeatureSet {
        export enum FieldPresence {
            FIELD_PRESENCE_UNKNOWN = 0,
            EXPLICIT = 1,
            IMPLICIT = 2,
            LEGACY_REQUIRED = 3
        }
        export enum EnumType {
            ENUM_TYPE_UNKNOWN = 0,
            OPEN = 1,
            CLOSED = 2
        }
        export enum RepeatedFieldEncoding {
            REPEATED_FIELD_ENCODING_UNKNOWN = 0,
            PACKED = 1,
            EXPANDED = 2
        }
        export enum Utf8Validation {
            UTF8_VALIDATION_UNKNOWN = 0,
            VERIFY = 2,
            NONE = 3
        }
        export enum MessageEncoding {
            MESSAGE_ENCODING_UNKNOWN = 0,
            LENGTH_PREFIXED = 1,
            DELIMITED = 2
        }
        export enum JsonFormat {
            JSON_FORMAT_UNKNOWN = 0,
            ALLOW = 1,
            LEGACY_BEST_EFFORT = 2
        }
    }
    export class FeatureSetDefaults extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            defaults: FeatureSetDefaults.FeatureSetEditionDefault[];
            minimumEdition?: Edition;
            maximumEdition?: Edition;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.defaults = data.defaults;
                if ("minimumEdition" in data && data.minimumEdition != undefined) {
                    this.minimumEdition = data.minimumEdition;
                }
                if ("maximumEdition" in data && data.maximumEdition != undefined) {
                    this.maximumEdition = data.maximumEdition;
                }
            }
        }
        get defaults() {
            return pb_1.Message.getRepeatedWrapperField(this, FeatureSetDefaults.FeatureSetEditionDefault, 1) as FeatureSetDefaults.FeatureSetEditionDefault[];
        }
        set defaults(value: FeatureSetDefaults.FeatureSetEditionDefault[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get minimumEdition() {
            return pb_1.Message.getFieldWithDefault(this, 4, Edition.EDITION_UNKNOWN) as Edition;
        }
        set minimumEdition(value: Edition) {
            pb_1.Message.setField(this, 4, value);
        }
        get hasMinimumEdition() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get maximumEdition() {
            return pb_1.Message.getFieldWithDefault(this, 5, Edition.EDITION_UNKNOWN) as Edition;
        }
        set maximumEdition(value: Edition) {
            pb_1.Message.setField(this, 5, value);
        }
        get hasMaximumEdition() {
            return pb_1.Message.getField(this, 5) != null;
        }
        static fromObject(data: {
            defaults?: ReturnType<typeof FeatureSetDefaults.FeatureSetEditionDefault.prototype.toObject>[];
            minimumEdition?: Edition;
            maximumEdition?: Edition;
        }): FeatureSetDefaults {
            const message = new FeatureSetDefaults({
                defaults: data.defaults.map(item => FeatureSetDefaults.FeatureSetEditionDefault.fromObject(item))
            });
            if (data.minimumEdition != null) {
                message.minimumEdition = data.minimumEdition;
            }
            if (data.maximumEdition != null) {
                message.maximumEdition = data.maximumEdition;
            }
            return message;
        }
        toObject() {
            const data: {
                defaults?: ReturnType<typeof FeatureSetDefaults.FeatureSetEditionDefault.prototype.toObject>[];
                minimumEdition?: Edition;
                maximumEdition?: Edition;
            } = {};
            if (this.defaults != null) {
                data.defaults = this.defaults.map((item: FeatureSetDefaults.FeatureSetEditionDefault) => item.toObject());
            }
            if (this.minimumEdition != null) {
                data.minimumEdition = this.minimumEdition;
            }
            if (this.maximumEdition != null) {
                data.maximumEdition = this.maximumEdition;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.defaults.length)
                writer.writeRepeatedMessage(1, this.defaults, (item: FeatureSetDefaults.FeatureSetEditionDefault) => item.serialize(writer));
            if (this.hasMinimumEdition)
                writer.writeEnum(4, this.minimumEdition);
            if (this.hasMaximumEdition)
                writer.writeEnum(5, this.maximumEdition);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeatureSetDefaults {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FeatureSetDefaults();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.defaults, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FeatureSetDefaults.FeatureSetEditionDefault.deserialize(reader), FeatureSetDefaults.FeatureSetEditionDefault));
                        break;
                    case 4:
                        message.minimumEdition = reader.readEnum();
                        break;
                    case 5:
                        message.maximumEdition = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FeatureSetDefaults {
            return FeatureSetDefaults.deserialize(bytes);
        }
    }
    export namespace FeatureSetDefaults {
        export class FeatureSetEditionDefault extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                edition?: Edition;
                overridableFeatures?: FeatureSet;
                fixedFeatures?: FeatureSet;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("edition" in data && data.edition != undefined) {
                        this.edition = data.edition;
                    }
                    if ("overridableFeatures" in data && data.overridableFeatures != undefined) {
                        this.overridableFeatures = data.overridableFeatures;
                    }
                    if ("fixedFeatures" in data && data.fixedFeatures != undefined) {
                        this.fixedFeatures = data.fixedFeatures;
                    }
                }
            }
            get edition() {
                return pb_1.Message.getFieldWithDefault(this, 3, Edition.EDITION_UNKNOWN) as Edition;
            }
            set edition(value: Edition) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasEdition() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get overridableFeatures() {
                return pb_1.Message.getWrapperField(this, FeatureSet, 4) as FeatureSet;
            }
            set overridableFeatures(value: FeatureSet) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            get hasOverridableFeatures() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get fixedFeatures() {
                return pb_1.Message.getWrapperField(this, FeatureSet, 5) as FeatureSet;
            }
            set fixedFeatures(value: FeatureSet) {
                pb_1.Message.setWrapperField(this, 5, value);
            }
            get hasFixedFeatures() {
                return pb_1.Message.getField(this, 5) != null;
            }
            static fromObject(data: {
                edition?: Edition;
                overridableFeatures?: ReturnType<typeof FeatureSet.prototype.toObject>;
                fixedFeatures?: ReturnType<typeof FeatureSet.prototype.toObject>;
            }): FeatureSetEditionDefault {
                const message = new FeatureSetEditionDefault({});
                if (data.edition != null) {
                    message.edition = data.edition;
                }
                if (data.overridableFeatures != null) {
                    message.overridableFeatures = FeatureSet.fromObject(data.overridableFeatures);
                }
                if (data.fixedFeatures != null) {
                    message.fixedFeatures = FeatureSet.fromObject(data.fixedFeatures);
                }
                return message;
            }
            toObject() {
                const data: {
                    edition?: Edition;
                    overridableFeatures?: ReturnType<typeof FeatureSet.prototype.toObject>;
                    fixedFeatures?: ReturnType<typeof FeatureSet.prototype.toObject>;
                } = {};
                if (this.edition != null) {
                    data.edition = this.edition;
                }
                if (this.overridableFeatures != null) {
                    data.overridableFeatures = this.overridableFeatures.toObject();
                }
                if (this.fixedFeatures != null) {
                    data.fixedFeatures = this.fixedFeatures.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hasEdition)
                    writer.writeEnum(3, this.edition);
                if (this.hasOverridableFeatures)
                    writer.writeMessage(4, this.overridableFeatures, () => this.overridableFeatures.serialize(writer));
                if (this.hasFixedFeatures)
                    writer.writeMessage(5, this.fixedFeatures, () => this.fixedFeatures.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeatureSetEditionDefault {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FeatureSetEditionDefault();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 3:
                            message.edition = reader.readEnum();
                            break;
                        case 4:
                            reader.readMessage(message.overridableFeatures, () => message.overridableFeatures = FeatureSet.deserialize(reader));
                            break;
                        case 5:
                            reader.readMessage(message.fixedFeatures, () => message.fixedFeatures = FeatureSet.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): FeatureSetEditionDefault {
                return FeatureSetEditionDefault.deserialize(bytes);
            }
        }
    }
    export class SourceCodeInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            location: SourceCodeInfo.Location[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.location = data.location;
            }
        }
        get location() {
            return pb_1.Message.getRepeatedWrapperField(this, SourceCodeInfo.Location, 1) as SourceCodeInfo.Location[];
        }
        set location(value: SourceCodeInfo.Location[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            location?: ReturnType<typeof SourceCodeInfo.Location.prototype.toObject>[];
        }): SourceCodeInfo {
            const message = new SourceCodeInfo({
                location: data.location.map(item => SourceCodeInfo.Location.fromObject(item))
            });
            return message;
        }
        toObject() {
            const data: {
                location?: ReturnType<typeof SourceCodeInfo.Location.prototype.toObject>[];
            } = {};
            if (this.location != null) {
                data.location = this.location.map((item: SourceCodeInfo.Location) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.location.length)
                writer.writeRepeatedMessage(1, this.location, (item: SourceCodeInfo.Location) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SourceCodeInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SourceCodeInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.location, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SourceCodeInfo.Location.deserialize(reader), SourceCodeInfo.Location));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SourceCodeInfo {
            return SourceCodeInfo.deserialize(bytes);
        }
    }
    export namespace SourceCodeInfo {
        export class Location extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                path: number[];
                span: number[];
                leadingComments?: string;
                trailingComments?: string;
                leadingDetachedComments: string[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 6], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    this.path = data.path;
                    this.span = data.span;
                    if ("leadingComments" in data && data.leadingComments != undefined) {
                        this.leadingComments = data.leadingComments;
                    }
                    if ("trailingComments" in data && data.trailingComments != undefined) {
                        this.trailingComments = data.trailingComments;
                    }
                    this.leadingDetachedComments = data.leadingDetachedComments;
                }
            }
            get path() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set path(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            get span() {
                return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
            }
            set span(value: number[]) {
                pb_1.Message.setField(this, 2, value);
            }
            get leadingComments() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set leadingComments(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasLeadingComments() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get trailingComments() {
                return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
            }
            set trailingComments(value: string) {
                pb_1.Message.setField(this, 4, value);
            }
            get hasTrailingComments() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get leadingDetachedComments() {
                return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
            }
            set leadingDetachedComments(value: string[]) {
                pb_1.Message.setField(this, 6, value);
            }
            static fromObject(data: {
                path: number[];
                span: number[];
                leadingComments?: string;
                trailingComments?: string;
                leadingDetachedComments: string[];
            }): Location {
                const message = new Location({
                    path: data.path,
                    span: data.span,
                    leadingDetachedComments: data.leadingDetachedComments
                });
                if (data.leadingComments != null) {
                    message.leadingComments = data.leadingComments;
                }
                if (data.trailingComments != null) {
                    message.trailingComments = data.trailingComments;
                }
                return message;
            }
            toObject() {
                const data: {
                    path: number[];
                    span: number[];
                    leadingComments?: string;
                    trailingComments?: string;
                    leadingDetachedComments: string[];
                } = {
                    path: this.path,
                    span: this.span,
                    leadingDetachedComments: this.leadingDetachedComments
                };
                if (this.leadingComments != null) {
                    data.leadingComments = this.leadingComments;
                }
                if (this.trailingComments != null) {
                    data.trailingComments = this.trailingComments;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.path.length)
                    writer.writePackedInt32(1, this.path);
                if (this.span.length)
                    writer.writePackedInt32(2, this.span);
                if (this.hasLeadingComments && this.leadingComments.length)
                    writer.writeString(3, this.leadingComments);
                if (this.hasTrailingComments && this.trailingComments.length)
                    writer.writeString(4, this.trailingComments);
                if (this.leadingDetachedComments.length)
                    writer.writeRepeatedString(6, this.leadingDetachedComments);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Location {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Location();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.path = reader.readPackedInt32();
                            break;
                        case 2:
                            message.span = reader.readPackedInt32();
                            break;
                        case 3:
                            message.leadingComments = reader.readString();
                            break;
                        case 4:
                            message.trailingComments = reader.readString();
                            break;
                        case 6:
                            pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Location {
                return Location.deserialize(bytes);
            }
        }
    }
    export class GeneratedCodeInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            annotation: GeneratedCodeInfo.Annotation[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.annotation = data.annotation;
            }
        }
        get annotation() {
            return pb_1.Message.getRepeatedWrapperField(this, GeneratedCodeInfo.Annotation, 1) as GeneratedCodeInfo.Annotation[];
        }
        set annotation(value: GeneratedCodeInfo.Annotation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            annotation?: ReturnType<typeof GeneratedCodeInfo.Annotation.prototype.toObject>[];
        }): GeneratedCodeInfo {
            const message = new GeneratedCodeInfo({
                annotation: data.annotation.map(item => GeneratedCodeInfo.Annotation.fromObject(item))
            });
            return message;
        }
        toObject() {
            const data: {
                annotation?: ReturnType<typeof GeneratedCodeInfo.Annotation.prototype.toObject>[];
            } = {};
            if (this.annotation != null) {
                data.annotation = this.annotation.map((item: GeneratedCodeInfo.Annotation) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.annotation.length)
                writer.writeRepeatedMessage(1, this.annotation, (item: GeneratedCodeInfo.Annotation) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeneratedCodeInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeneratedCodeInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.annotation, () => pb_1.Message.addToRepeatedWrapperField(message, 1, GeneratedCodeInfo.Annotation.deserialize(reader), GeneratedCodeInfo.Annotation));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GeneratedCodeInfo {
            return GeneratedCodeInfo.deserialize(bytes);
        }
    }
    export namespace GeneratedCodeInfo {
        export class Annotation extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                path: number[];
                sourceFile?: string;
                begin?: number;
                end?: number;
                semantic?: GeneratedCodeInfo.Annotation.Semantic;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    this.path = data.path;
                    if ("sourceFile" in data && data.sourceFile != undefined) {
                        this.sourceFile = data.sourceFile;
                    }
                    if ("begin" in data && data.begin != undefined) {
                        this.begin = data.begin;
                    }
                    if ("end" in data && data.end != undefined) {
                        this.end = data.end;
                    }
                    if ("semantic" in data && data.semantic != undefined) {
                        this.semantic = data.semantic;
                    }
                }
            }
            get path() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set path(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            get sourceFile() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set sourceFile(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get hasSourceFile() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get begin() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set begin(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get hasBegin() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get end() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set end(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get hasEnd() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get semantic() {
                return pb_1.Message.getFieldWithDefault(this, 5, GeneratedCodeInfo.Annotation.Semantic.NONE) as GeneratedCodeInfo.Annotation.Semantic;
            }
            set semantic(value: GeneratedCodeInfo.Annotation.Semantic) {
                pb_1.Message.setField(this, 5, value);
            }
            get hasSemantic() {
                return pb_1.Message.getField(this, 5) != null;
            }
            static fromObject(data: {
                path: number[];
                sourceFile?: string;
                begin?: number;
                end?: number;
                semantic?: GeneratedCodeInfo.Annotation.Semantic;
            }): Annotation {
                const message = new Annotation({
                    path: data.path
                });
                if (data.sourceFile != null) {
                    message.sourceFile = data.sourceFile;
                }
                if (data.begin != null) {
                    message.begin = data.begin;
                }
                if (data.end != null) {
                    message.end = data.end;
                }
                if (data.semantic != null) {
                    message.semantic = data.semantic;
                }
                return message;
            }
            toObject() {
                const data: {
                    path: number[];
                    sourceFile?: string;
                    begin?: number;
                    end?: number;
                    semantic?: GeneratedCodeInfo.Annotation.Semantic;
                } = {
                    path: this.path
                };
                if (this.sourceFile != null) {
                    data.sourceFile = this.sourceFile;
                }
                if (this.begin != null) {
                    data.begin = this.begin;
                }
                if (this.end != null) {
                    data.end = this.end;
                }
                if (this.semantic != null) {
                    data.semantic = this.semantic;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.path.length)
                    writer.writePackedInt32(1, this.path);
                if (this.hasSourceFile && this.sourceFile.length)
                    writer.writeString(2, this.sourceFile);
                if (this.hasBegin)
                    writer.writeInt32(3, this.begin);
                if (this.hasEnd)
                    writer.writeInt32(4, this.end);
                if (this.hasSemantic)
                    writer.writeEnum(5, this.semantic);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Annotation {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Annotation();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.path = reader.readPackedInt32();
                            break;
                        case 2:
                            message.sourceFile = reader.readString();
                            break;
                        case 3:
                            message.begin = reader.readInt32();
                            break;
                        case 4:
                            message.end = reader.readInt32();
                            break;
                        case 5:
                            message.semantic = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Annotation {
                return Annotation.deserialize(bytes);
            }
        }
        export namespace Annotation {
            export enum Semantic {
                NONE = 0,
                SET = 1,
                ALIAS = 2
            }
        }
    }
}
