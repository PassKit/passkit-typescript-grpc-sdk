/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.0
 * source: io/common/common_objects.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../protoc-gen-openapiv2/options/annotations";
import * as dependency_2 from "./pagination";
import * as dependency_3 from "./filter";
import * as dependency_4 from "./protocols";
import * as pb_1 from "google-protobuf";
export namespace io {
    export enum ListPosition {
        APPEND = 0,
        PREPEND = 1,
        REPLACE = 2
    }
    export enum Toggle {
        DO_NOT_USE = 0,
        ON = 1,
        OFF = 2
    }
    export enum TimeState {
        TIME_STATE_NONE = 0,
        TIME_STATE_CURRENT = 1,
        TIME_STATE_PREVIOUS = 2,
        TIME_STATE_FOLLOWING = 3
    }
    export enum PassBundleFormat {
        PASS_URL = 0,
        GOOGLE_URL = 2,
        APPLE_PASS_BUNDLE = 8,
        MULTI_LINK = 16
    }
    export enum UsageType {
        NO_USAGE = 0,
        USAGE_APPLE_WALLET = 1,
        USAGE_GOOGLE_PAY = 2,
        USAGE_DATA_COLLECTION_PAGE = 4
    }
    export class Id extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            id?: string;
        }): Id {
            const message = new Id({});
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Id {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Id();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Id {
            return Id.deserialize(bytes);
        }
    }
    export class Ids extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set id(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            id?: string[];
        }): Ids {
            const message = new Ids({});
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeRepeatedString(1, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Ids {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Ids();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Ids {
            return Ids.deserialize(bytes);
        }
    }
    export class Url extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            url?: string;
            title?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("url" in data && data.url != undefined) {
                    this.url = data.url;
                }
                if ("title" in data && data.title != undefined) {
                    this.title = data.title;
                }
            }
        }
        get url() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set url(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get title() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set title(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            url?: string;
            title?: string;
        }): Url {
            const message = new Url({});
            if (data.url != null) {
                message.url = data.url;
            }
            if (data.title != null) {
                message.title = data.title;
            }
            return message;
        }
        toObject() {
            const data: {
                url?: string;
                title?: string;
            } = {};
            if (this.url != null) {
                data.url = this.url;
            }
            if (this.title != null) {
                data.title = this.title;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.url.length)
                writer.writeString(1, this.url);
            if (this.title.length)
                writer.writeString(2, this.title);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Url {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Url();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.url = reader.readString();
                        break;
                    case 2:
                        message.title = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Url {
            return Url.deserialize(bytes);
        }
    }
    export class Count extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            total?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("total" in data && data.total != undefined) {
                    this.total = data.total;
                }
            }
        }
        get total() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set total(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            total?: number;
        }): Count {
            const message = new Count({});
            if (data.total != null) {
                message.total = data.total;
            }
            return message;
        }
        toObject() {
            const data: {
                total?: number;
            } = {};
            if (this.total != null) {
                data.total = this.total;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.total != 0)
                writer.writeInt32(1, this.total);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Count {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Count();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.total = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Count {
            return Count.deserialize(bytes);
        }
    }
    export class FileBytes extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fileBytes?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fileBytes" in data && data.fileBytes != undefined) {
                    this.fileBytes = data.fileBytes;
                }
            }
        }
        get fileBytes() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set fileBytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            fileBytes?: Uint8Array;
        }): FileBytes {
            const message = new FileBytes({});
            if (data.fileBytes != null) {
                message.fileBytes = data.fileBytes;
            }
            return message;
        }
        toObject() {
            const data: {
                fileBytes?: Uint8Array;
            } = {};
            if (this.fileBytes != null) {
                data.fileBytes = this.fileBytes;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.fileBytes.length)
                writer.writeBytes(1, this.fileBytes);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileBytes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileBytes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.fileBytes = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileBytes {
            return FileBytes.deserialize(bytes);
        }
    }
    export class Boolean extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            response?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("response" in data && data.response != undefined) {
                    this.response = data.response;
                }
            }
        }
        get response() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set response(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            response?: boolean;
        }): Boolean {
            const message = new Boolean({});
            if (data.response != null) {
                message.response = data.response;
            }
            return message;
        }
        toObject() {
            const data: {
                response?: boolean;
            } = {};
            if (this.response != null) {
                data.response = this.response;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.response != false)
                writer.writeBool(1, this.response);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Boolean {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Boolean();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.response = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Boolean {
            return Boolean.deserialize(bytes);
        }
    }
    export class Strings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            response?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("response" in data && data.response != undefined) {
                    this.response = data.response;
                }
            }
        }
        get response() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set response(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            response?: string[];
        }): Strings {
            const message = new Strings({});
            if (data.response != null) {
                message.response = data.response;
            }
            return message;
        }
        toObject() {
            const data: {
                response?: string[];
            } = {};
            if (this.response != null) {
                data.response = this.response;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.response.length)
                writer.writeRepeatedString(1, this.response);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Strings {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Strings();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Strings {
            return Strings.deserialize(bytes);
        }
    }
    export class Payload extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            payload?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("payload" in data && data.payload != undefined) {
                    this.payload = data.payload;
                }
            }
        }
        get payload() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set payload(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            payload?: string;
        }): Payload {
            const message = new Payload({});
            if (data.payload != null) {
                message.payload = data.payload;
            }
            return message;
        }
        toObject() {
            const data: {
                payload?: string;
            } = {};
            if (this.payload != null) {
                data.payload = this.payload;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.payload.length)
                writer.writeString(1, this.payload);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Payload {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Payload();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.payload = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Payload {
            return Payload.deserialize(bytes);
        }
    }
    export class Date extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            year?: number;
            month?: number;
            day?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("year" in data && data.year != undefined) {
                    this.year = data.year;
                }
                if ("month" in data && data.month != undefined) {
                    this.month = data.month;
                }
                if ("day" in data && data.day != undefined) {
                    this.day = data.day;
                }
            }
        }
        get year() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set year(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get month() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set month(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get day() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set day(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            year?: number;
            month?: number;
            day?: number;
        }): Date {
            const message = new Date({});
            if (data.year != null) {
                message.year = data.year;
            }
            if (data.month != null) {
                message.month = data.month;
            }
            if (data.day != null) {
                message.day = data.day;
            }
            return message;
        }
        toObject() {
            const data: {
                year?: number;
                month?: number;
                day?: number;
            } = {};
            if (this.year != null) {
                data.year = this.year;
            }
            if (this.month != null) {
                data.month = this.month;
            }
            if (this.day != null) {
                data.day = this.day;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.year != 0)
                writer.writeInt32(1, this.year);
            if (this.month != 0)
                writer.writeInt32(2, this.month);
            if (this.day != 0)
                writer.writeInt32(3, this.day);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Date {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Date();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.year = reader.readInt32();
                        break;
                    case 2:
                        message.month = reader.readInt32();
                        break;
                    case 3:
                        message.day = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Date {
            return Date.deserialize(bytes);
        }
    }
    export class Time extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            hour?: number;
            minute?: number;
            second?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hour" in data && data.hour != undefined) {
                    this.hour = data.hour;
                }
                if ("minute" in data && data.minute != undefined) {
                    this.minute = data.minute;
                }
                if ("second" in data && data.second != undefined) {
                    this.second = data.second;
                }
            }
        }
        get hour() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set hour(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get minute() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set minute(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get second() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set second(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            hour?: number;
            minute?: number;
            second?: number;
        }): Time {
            const message = new Time({});
            if (data.hour != null) {
                message.hour = data.hour;
            }
            if (data.minute != null) {
                message.minute = data.minute;
            }
            if (data.second != null) {
                message.second = data.second;
            }
            return message;
        }
        toObject() {
            const data: {
                hour?: number;
                minute?: number;
                second?: number;
            } = {};
            if (this.hour != null) {
                data.hour = this.hour;
            }
            if (this.minute != null) {
                data.minute = this.minute;
            }
            if (this.second != null) {
                data.second = this.second;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hour != 0)
                writer.writeInt32(1, this.hour);
            if (this.minute != 0)
                writer.writeInt32(2, this.minute);
            if (this.second != 0)
                writer.writeInt32(3, this.second);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Time {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Time();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hour = reader.readInt32();
                        break;
                    case 2:
                        message.minute = reader.readInt32();
                        break;
                    case 3:
                        message.second = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Time {
            return Time.deserialize(bytes);
        }
    }
    export class LocalDate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            dateTime?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("dateTime" in data && data.dateTime != undefined) {
                    this.dateTime = data.dateTime;
                }
            }
        }
        get dateTime() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set dateTime(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            dateTime?: string;
        }): LocalDate {
            const message = new LocalDate({});
            if (data.dateTime != null) {
                message.dateTime = data.dateTime;
            }
            return message;
        }
        toObject() {
            const data: {
                dateTime?: string;
            } = {};
            if (this.dateTime != null) {
                data.dateTime = this.dateTime;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.dateTime.length)
                writer.writeString(1, this.dateTime);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocalDate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocalDate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.dateTime = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocalDate {
            return LocalDate.deserialize(bytes);
        }
    }
    export class LocalDateTime extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            dateTime?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("dateTime" in data && data.dateTime != undefined) {
                    this.dateTime = data.dateTime;
                }
            }
        }
        get dateTime() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set dateTime(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            dateTime?: string;
        }): LocalDateTime {
            const message = new LocalDateTime({});
            if (data.dateTime != null) {
                message.dateTime = data.dateTime;
            }
            return message;
        }
        toObject() {
            const data: {
                dateTime?: string;
            } = {};
            if (this.dateTime != null) {
                data.dateTime = this.dateTime;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.dateTime.length)
                writer.writeString(1, this.dateTime);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocalDateTime {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocalDateTime();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.dateTime = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocalDateTime {
            return LocalDateTime.deserialize(bytes);
        }
    }
    export class PassBundle extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            url?: string;
            googlePayURL?: string;
            applePassBytes?: Uint8Array;
            multiplePassesURL?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("url" in data && data.url != undefined) {
                    this.url = data.url;
                }
                if ("googlePayURL" in data && data.googlePayURL != undefined) {
                    this.googlePayURL = data.googlePayURL;
                }
                if ("applePassBytes" in data && data.applePassBytes != undefined) {
                    this.applePassBytes = data.applePassBytes;
                }
                if ("multiplePassesURL" in data && data.multiplePassesURL != undefined) {
                    this.multiplePassesURL = data.multiplePassesURL;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get url() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set url(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get googlePayURL() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set googlePayURL(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get applePassBytes() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set applePassBytes(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get multiplePassesURL() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set multiplePassesURL(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            id?: string;
            url?: string;
            googlePayURL?: string;
            applePassBytes?: Uint8Array;
            multiplePassesURL?: string;
        }): PassBundle {
            const message = new PassBundle({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.url != null) {
                message.url = data.url;
            }
            if (data.googlePayURL != null) {
                message.googlePayURL = data.googlePayURL;
            }
            if (data.applePassBytes != null) {
                message.applePassBytes = data.applePassBytes;
            }
            if (data.multiplePassesURL != null) {
                message.multiplePassesURL = data.multiplePassesURL;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                url?: string;
                googlePayURL?: string;
                applePassBytes?: Uint8Array;
                multiplePassesURL?: string;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.url != null) {
                data.url = this.url;
            }
            if (this.googlePayURL != null) {
                data.googlePayURL = this.googlePayURL;
            }
            if (this.applePassBytes != null) {
                data.applePassBytes = this.applePassBytes;
            }
            if (this.multiplePassesURL != null) {
                data.multiplePassesURL = this.multiplePassesURL;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.url.length)
                writer.writeString(2, this.url);
            if (this.googlePayURL.length)
                writer.writeString(5, this.googlePayURL);
            if (this.applePassBytes.length)
                writer.writeBytes(6, this.applePassBytes);
            if (this.multiplePassesURL.length)
                writer.writeString(7, this.multiplePassesURL);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PassBundle {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PassBundle();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.url = reader.readString();
                        break;
                    case 5:
                        message.googlePayURL = reader.readString();
                        break;
                    case 6:
                        message.applePassBytes = reader.readBytes();
                        break;
                    case 7:
                        message.multiplePassesURL = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PassBundle {
            return PassBundle.deserialize(bytes);
        }
    }
    export class PassBundles extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            passes?: PassBundle[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("passes" in data && data.passes != undefined) {
                    this.passes = data.passes;
                }
            }
        }
        get passes() {
            return pb_1.Message.getRepeatedWrapperField(this, PassBundle, 1) as PassBundle[];
        }
        set passes(value: PassBundle[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            passes?: ReturnType<typeof PassBundle.prototype.toObject>[];
        }): PassBundles {
            const message = new PassBundles({});
            if (data.passes != null) {
                message.passes = data.passes.map(item => PassBundle.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                passes?: ReturnType<typeof PassBundle.prototype.toObject>[];
            } = {};
            if (this.passes != null) {
                data.passes = this.passes.map((item: PassBundle) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.passes.length)
                writer.writeRepeatedMessage(1, this.passes, (item: PassBundle) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PassBundles {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PassBundles();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.passes, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PassBundle.deserialize(reader), PassBundle));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PassBundles {
            return PassBundles.deserialize(bytes);
        }
    }
    export class PassBundleRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            format?: PassBundleFormat[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("format" in data && data.format != undefined) {
                    this.format = data.format;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get format() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as PassBundleFormat[];
        }
        set format(value: PassBundleFormat[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            id?: string;
            format?: PassBundleFormat[];
        }): PassBundleRequest {
            const message = new PassBundleRequest({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.format != null) {
                message.format = data.format;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                format?: PassBundleFormat[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.format != null) {
                data.format = this.format;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.format.length)
                writer.writePackedEnum(2, this.format);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PassBundleRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PassBundleRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.format = reader.readPackedEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PassBundleRequest {
            return PassBundleRequest.deserialize(bytes);
        }
    }
    export class ListRequestDeprecated extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            pagination?: dependency_2.io.Pagination;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("classId" in data && data.classId != undefined) {
                    this.classId = data.classId;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("pagination" in data && data.pagination != undefined) {
                    this.pagination = data.pagination;
                }
            }
        }
        get classId() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set classId(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 2, dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE) as dependency_4.io.PassProtocol;
        }
        set protocol(value: dependency_4.io.PassProtocol) {
            pb_1.Message.setField(this, 2, value);
        }
        get pagination() {
            return pb_1.Message.getWrapperField(this, dependency_2.io.Pagination, 3) as dependency_2.io.Pagination;
        }
        set pagination(value: dependency_2.io.Pagination) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasPagination() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            pagination?: ReturnType<typeof dependency_2.io.Pagination.prototype.toObject>;
        }): ListRequestDeprecated {
            const message = new ListRequestDeprecated({});
            if (data.classId != null) {
                message.classId = data.classId;
            }
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (data.pagination != null) {
                message.pagination = dependency_2.io.Pagination.fromObject(data.pagination);
            }
            return message;
        }
        toObject() {
            const data: {
                classId?: string;
                protocol?: dependency_4.io.PassProtocol;
                pagination?: ReturnType<typeof dependency_2.io.Pagination.prototype.toObject>;
            } = {};
            if (this.classId != null) {
                data.classId = this.classId;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.pagination != null) {
                data.pagination = this.pagination.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.classId.length)
                writer.writeString(1, this.classId);
            if (this.protocol != dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE)
                writer.writeEnum(2, this.protocol);
            if (this.hasPagination)
                writer.writeMessage(3, this.pagination, () => this.pagination.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListRequestDeprecated {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListRequestDeprecated();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.classId = reader.readString();
                        break;
                    case 2:
                        message.protocol = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.pagination, () => message.pagination = dependency_2.io.Pagination.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListRequestDeprecated {
            return ListRequestDeprecated.deserialize(bytes);
        }
    }
    export class ListRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            filters?: dependency_3.io.Filters;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("classId" in data && data.classId != undefined) {
                    this.classId = data.classId;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("filters" in data && data.filters != undefined) {
                    this.filters = data.filters;
                }
            }
        }
        get classId() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set classId(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 2, dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE) as dependency_4.io.PassProtocol;
        }
        set protocol(value: dependency_4.io.PassProtocol) {
            pb_1.Message.setField(this, 2, value);
        }
        get filters() {
            return pb_1.Message.getWrapperField(this, dependency_3.io.Filters, 3) as dependency_3.io.Filters;
        }
        set filters(value: dependency_3.io.Filters) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasFilters() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            filters?: ReturnType<typeof dependency_3.io.Filters.prototype.toObject>;
        }): ListRequest {
            const message = new ListRequest({});
            if (data.classId != null) {
                message.classId = data.classId;
            }
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (data.filters != null) {
                message.filters = dependency_3.io.Filters.fromObject(data.filters);
            }
            return message;
        }
        toObject() {
            const data: {
                classId?: string;
                protocol?: dependency_4.io.PassProtocol;
                filters?: ReturnType<typeof dependency_3.io.Filters.prototype.toObject>;
            } = {};
            if (this.classId != null) {
                data.classId = this.classId;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.filters != null) {
                data.filters = this.filters.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.classId.length)
                writer.writeString(1, this.classId);
            if (this.protocol != dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE)
                writer.writeEnum(2, this.protocol);
            if (this.hasFilters)
                writer.writeMessage(3, this.filters, () => this.filters.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.classId = reader.readString();
                        break;
                    case 2:
                        message.protocol = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.filters, () => message.filters = dependency_3.io.Filters.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListRequest {
            return ListRequest.deserialize(bytes);
        }
    }
    export class BulkPassActionRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            filterGroups?: dependency_3.io.FilterGroup[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("classId" in data && data.classId != undefined) {
                    this.classId = data.classId;
                }
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("filterGroups" in data && data.filterGroups != undefined) {
                    this.filterGroups = data.filterGroups;
                }
            }
        }
        get classId() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set classId(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 2, dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE) as dependency_4.io.PassProtocol;
        }
        set protocol(value: dependency_4.io.PassProtocol) {
            pb_1.Message.setField(this, 2, value);
        }
        get filterGroups() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.io.FilterGroup, 3) as dependency_3.io.FilterGroup[];
        }
        set filterGroups(value: dependency_3.io.FilterGroup[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            classId?: string;
            protocol?: dependency_4.io.PassProtocol;
            filterGroups?: ReturnType<typeof dependency_3.io.FilterGroup.prototype.toObject>[];
        }): BulkPassActionRequest {
            const message = new BulkPassActionRequest({});
            if (data.classId != null) {
                message.classId = data.classId;
            }
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (data.filterGroups != null) {
                message.filterGroups = data.filterGroups.map(item => dependency_3.io.FilterGroup.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                classId?: string;
                protocol?: dependency_4.io.PassProtocol;
                filterGroups?: ReturnType<typeof dependency_3.io.FilterGroup.prototype.toObject>[];
            } = {};
            if (this.classId != null) {
                data.classId = this.classId;
            }
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.filterGroups != null) {
                data.filterGroups = this.filterGroups.map((item: dependency_3.io.FilterGroup) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.classId.length)
                writer.writeString(1, this.classId);
            if (this.protocol != dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE)
                writer.writeEnum(2, this.protocol);
            if (this.filterGroups.length)
                writer.writeRepeatedMessage(3, this.filterGroups, (item: dependency_3.io.FilterGroup) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BulkPassActionRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BulkPassActionRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.classId = reader.readString();
                        break;
                    case 2:
                        message.protocol = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.filterGroups, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_3.io.FilterGroup.deserialize(reader), dependency_3.io.FilterGroup));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BulkPassActionRequest {
            return BulkPassActionRequest.deserialize(bytes);
        }
    }
    export class DataItems extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            items?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("items" in data && data.items != undefined) {
                    this.items = data.items;
                }
            }
            if (!this.items)
                this.items = new Map();
        }
        get items() {
            return pb_1.Message.getField(this, 1) as any as Map<string, string>;
        }
        set items(value: Map<string, string>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            items?: {
                [key: string]: string;
            };
        }): DataItems {
            const message = new DataItems({});
            if (typeof data.items == "object") {
                message.items = new Map(Object.entries(data.items));
            }
            return message;
        }
        toObject() {
            const data: {
                items?: {
                    [key: string]: string;
                };
            } = {};
            if (this.items != null) {
                data.items = (Object.fromEntries)(this.items);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.items) {
                writer.writeMessage(1, this.items, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DataItems {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DataItems();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.items as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DataItems {
            return DataItems.deserialize(bytes);
        }
    }
    export class PkBool extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ok?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ok" in data && data.ok != undefined) {
                    this.ok = data.ok;
                }
            }
        }
        get ok() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set ok(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ok?: boolean;
        }): PkBool {
            const message = new PkBool({});
            if (data.ok != null) {
                message.ok = data.ok;
            }
            return message;
        }
        toObject() {
            const data: {
                ok?: boolean;
            } = {};
            if (this.ok != null) {
                data.ok = this.ok;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ok != false)
                writer.writeBool(1, this.ok);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PkBool {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PkBool();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ok = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PkBool {
            return PkBool.deserialize(bytes);
        }
    }
    export class ClassObjectInput extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            protocol?: dependency_4.io.PassProtocol;
            objectId?: string;
            classId?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("objectId" in data && data.objectId != undefined) {
                    this.objectId = data.objectId;
                }
                if ("classId" in data && data.classId != undefined) {
                    this.classId = data.classId;
                }
            }
        }
        get protocol() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE) as dependency_4.io.PassProtocol;
        }
        set protocol(value: dependency_4.io.PassProtocol) {
            pb_1.Message.setField(this, 1, value);
        }
        get objectId() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set objectId(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get classId() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set classId(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            protocol?: dependency_4.io.PassProtocol;
            objectId?: string;
            classId?: string;
        }): ClassObjectInput {
            const message = new ClassObjectInput({});
            if (data.protocol != null) {
                message.protocol = data.protocol;
            }
            if (data.objectId != null) {
                message.objectId = data.objectId;
            }
            if (data.classId != null) {
                message.classId = data.classId;
            }
            return message;
        }
        toObject() {
            const data: {
                protocol?: dependency_4.io.PassProtocol;
                objectId?: string;
                classId?: string;
            } = {};
            if (this.protocol != null) {
                data.protocol = this.protocol;
            }
            if (this.objectId != null) {
                data.objectId = this.objectId;
            }
            if (this.classId != null) {
                data.classId = this.classId;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.protocol != dependency_4.io.PassProtocol.PASS_PROTOCOL_DO_NOT_USE)
                writer.writeEnum(1, this.protocol);
            if (this.objectId.length)
                writer.writeString(2, this.objectId);
            if (this.classId.length)
                writer.writeString(3, this.classId);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClassObjectInput {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClassObjectInput();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.protocol = reader.readEnum();
                        break;
                    case 2:
                        message.objectId = reader.readString();
                        break;
                    case 3:
                        message.classId = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ClassObjectInput {
            return ClassObjectInput.deserialize(bytes);
        }
    }
    export class RecursiveDate extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            schedule?: string;
            state?: TimeState;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("schedule" in data && data.schedule != undefined) {
                    this.schedule = data.schedule;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
            }
        }
        get schedule() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set schedule(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 2, TimeState.TIME_STATE_NONE) as TimeState;
        }
        set state(value: TimeState) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            schedule?: string;
            state?: TimeState;
        }): RecursiveDate {
            const message = new RecursiveDate({});
            if (data.schedule != null) {
                message.schedule = data.schedule;
            }
            if (data.state != null) {
                message.state = data.state;
            }
            return message;
        }
        toObject() {
            const data: {
                schedule?: string;
                state?: TimeState;
            } = {};
            if (this.schedule != null) {
                data.schedule = this.schedule;
            }
            if (this.state != null) {
                data.state = this.state;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.schedule.length)
                writer.writeString(1, this.schedule);
            if (this.state != TimeState.TIME_STATE_NONE)
                writer.writeEnum(2, this.state);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RecursiveDate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RecursiveDate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.schedule = reader.readString();
                        break;
                    case 2:
                        message.state = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RecursiveDate {
            return RecursiveDate.deserialize(bytes);
        }
    }
    export class MonthlyRecursive extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            dayOfMonth?: number;
            hour?: number;
            minute?: number;
            second?: number;
            state?: TimeState;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("dayOfMonth" in data && data.dayOfMonth != undefined) {
                    this.dayOfMonth = data.dayOfMonth;
                }
                if ("hour" in data && data.hour != undefined) {
                    this.hour = data.hour;
                }
                if ("minute" in data && data.minute != undefined) {
                    this.minute = data.minute;
                }
                if ("second" in data && data.second != undefined) {
                    this.second = data.second;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
            }
        }
        get dayOfMonth() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set dayOfMonth(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get hour() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set hour(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get minute() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set minute(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get second() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set second(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 5, TimeState.TIME_STATE_NONE) as TimeState;
        }
        set state(value: TimeState) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            dayOfMonth?: number;
            hour?: number;
            minute?: number;
            second?: number;
            state?: TimeState;
        }): MonthlyRecursive {
            const message = new MonthlyRecursive({});
            if (data.dayOfMonth != null) {
                message.dayOfMonth = data.dayOfMonth;
            }
            if (data.hour != null) {
                message.hour = data.hour;
            }
            if (data.minute != null) {
                message.minute = data.minute;
            }
            if (data.second != null) {
                message.second = data.second;
            }
            if (data.state != null) {
                message.state = data.state;
            }
            return message;
        }
        toObject() {
            const data: {
                dayOfMonth?: number;
                hour?: number;
                minute?: number;
                second?: number;
                state?: TimeState;
            } = {};
            if (this.dayOfMonth != null) {
                data.dayOfMonth = this.dayOfMonth;
            }
            if (this.hour != null) {
                data.hour = this.hour;
            }
            if (this.minute != null) {
                data.minute = this.minute;
            }
            if (this.second != null) {
                data.second = this.second;
            }
            if (this.state != null) {
                data.state = this.state;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.dayOfMonth != 0)
                writer.writeInt32(1, this.dayOfMonth);
            if (this.hour != 0)
                writer.writeInt32(2, this.hour);
            if (this.minute != 0)
                writer.writeInt32(3, this.minute);
            if (this.second != 0)
                writer.writeInt32(4, this.second);
            if (this.state != TimeState.TIME_STATE_NONE)
                writer.writeEnum(5, this.state);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MonthlyRecursive {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MonthlyRecursive();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.dayOfMonth = reader.readInt32();
                        break;
                    case 2:
                        message.hour = reader.readInt32();
                        break;
                    case 3:
                        message.minute = reader.readInt32();
                        break;
                    case 4:
                        message.second = reader.readInt32();
                        break;
                    case 5:
                        message.state = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MonthlyRecursive {
            return MonthlyRecursive.deserialize(bytes);
        }
    }
    export class YearlyRecursive extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            month?: number;
            dayOfMonth?: number;
            hour?: number;
            minute?: number;
            second?: number;
            state?: TimeState;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("month" in data && data.month != undefined) {
                    this.month = data.month;
                }
                if ("dayOfMonth" in data && data.dayOfMonth != undefined) {
                    this.dayOfMonth = data.dayOfMonth;
                }
                if ("hour" in data && data.hour != undefined) {
                    this.hour = data.hour;
                }
                if ("minute" in data && data.minute != undefined) {
                    this.minute = data.minute;
                }
                if ("second" in data && data.second != undefined) {
                    this.second = data.second;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
            }
        }
        get month() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set month(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get dayOfMonth() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set dayOfMonth(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get hour() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set hour(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get minute() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set minute(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get second() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set second(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 6, TimeState.TIME_STATE_NONE) as TimeState;
        }
        set state(value: TimeState) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            month?: number;
            dayOfMonth?: number;
            hour?: number;
            minute?: number;
            second?: number;
            state?: TimeState;
        }): YearlyRecursive {
            const message = new YearlyRecursive({});
            if (data.month != null) {
                message.month = data.month;
            }
            if (data.dayOfMonth != null) {
                message.dayOfMonth = data.dayOfMonth;
            }
            if (data.hour != null) {
                message.hour = data.hour;
            }
            if (data.minute != null) {
                message.minute = data.minute;
            }
            if (data.second != null) {
                message.second = data.second;
            }
            if (data.state != null) {
                message.state = data.state;
            }
            return message;
        }
        toObject() {
            const data: {
                month?: number;
                dayOfMonth?: number;
                hour?: number;
                minute?: number;
                second?: number;
                state?: TimeState;
            } = {};
            if (this.month != null) {
                data.month = this.month;
            }
            if (this.dayOfMonth != null) {
                data.dayOfMonth = this.dayOfMonth;
            }
            if (this.hour != null) {
                data.hour = this.hour;
            }
            if (this.minute != null) {
                data.minute = this.minute;
            }
            if (this.second != null) {
                data.second = this.second;
            }
            if (this.state != null) {
                data.state = this.state;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.month != 0)
                writer.writeInt32(1, this.month);
            if (this.dayOfMonth != 0)
                writer.writeInt32(2, this.dayOfMonth);
            if (this.hour != 0)
                writer.writeInt32(3, this.hour);
            if (this.minute != 0)
                writer.writeInt32(4, this.minute);
            if (this.second != 0)
                writer.writeInt32(5, this.second);
            if (this.state != TimeState.TIME_STATE_NONE)
                writer.writeEnum(6, this.state);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YearlyRecursive {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new YearlyRecursive();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.month = reader.readInt32();
                        break;
                    case 2:
                        message.dayOfMonth = reader.readInt32();
                        break;
                    case 3:
                        message.hour = reader.readInt32();
                        break;
                    case 4:
                        message.minute = reader.readInt32();
                        break;
                    case 5:
                        message.second = reader.readInt32();
                        break;
                    case 6:
                        message.state = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): YearlyRecursive {
            return YearlyRecursive.deserialize(bytes);
        }
    }
    export class PassIds extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ids?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ids" in data && data.ids != undefined) {
                    this.ids = data.ids;
                }
            }
        }
        get ids() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set ids(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ids?: string[];
        }): PassIds {
            const message = new PassIds({});
            if (data.ids != null) {
                message.ids = data.ids;
            }
            return message;
        }
        toObject() {
            const data: {
                ids?: string[];
            } = {};
            if (this.ids != null) {
                data.ids = this.ids;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ids.length)
                writer.writeRepeatedString(1, this.ids);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PassIds {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PassIds();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PassIds {
            return PassIds.deserialize(bytes);
        }
    }
    export class Protocol extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            protocol?: Protocol;
            classId?: string;
            pagination?: dependency_2.io.Pagination;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("protocol" in data && data.protocol != undefined) {
                    this.protocol = data.protocol;
                }
                if ("classId" in data && data.classId != undefined) {
                    this.classId = data.classId;
                }
                if ("pagination" in data && data.pagination != undefined) {
                    this.pagination = data.pagination;
                }
            }
        }
        get protocol() {
            return pb_1.Message.getWrapperField(this, Protocol, 1) as Protocol;
        }
        set protocol(value: Protocol) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get hasProtocol() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get classId() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set classId(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get pagination() {
            return pb_1.Message.getWrapperField(this, dependency_2.io.Pagination, 3) as dependency_2.io.Pagination;
        }
        set pagination(value: dependency_2.io.Pagination) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get hasPagination() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            protocol?: ReturnType<typeof Protocol.prototype.toObject>;
            classId?: string;
            pagination?: ReturnType<typeof dependency_2.io.Pagination.prototype.toObject>;
        }): Protocol {
            const message = new Protocol({});
            if (data.protocol != null) {
                message.protocol = Protocol.fromObject(data.protocol);
            }
            if (data.classId != null) {
                message.classId = data.classId;
            }
            if (data.pagination != null) {
                message.pagination = dependency_2.io.Pagination.fromObject(data.pagination);
            }
            return message;
        }
        toObject() {
            const data: {
                protocol?: ReturnType<typeof Protocol.prototype.toObject>;
                classId?: string;
                pagination?: ReturnType<typeof dependency_2.io.Pagination.prototype.toObject>;
            } = {};
            if (this.protocol != null) {
                data.protocol = this.protocol.toObject();
            }
            if (this.classId != null) {
                data.classId = this.classId;
            }
            if (this.pagination != null) {
                data.pagination = this.pagination.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hasProtocol)
                writer.writeMessage(1, this.protocol, () => this.protocol.serialize(writer));
            if (this.classId.length)
                writer.writeString(2, this.classId);
            if (this.hasPagination)
                writer.writeMessage(3, this.pagination, () => this.pagination.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Protocol {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Protocol();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.protocol, () => message.protocol = Protocol.deserialize(reader));
                        break;
                    case 2:
                        message.classId = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.pagination, () => message.pagination = dependency_2.io.Pagination.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Protocol {
            return Protocol.deserialize(bytes);
        }
    }
}
